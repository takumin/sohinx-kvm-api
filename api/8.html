

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8. Other capabilities. &mdash; Linux KVM  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="7. Capabilities that can be enabled on VMs" href="7.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Linux KVM
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table Of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1.html">1. General description</a></li>
<li class="toctree-l1"><a class="reference internal" href="2.html">2. File descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="3.html">3. Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="4.html">4. API description</a></li>
<li class="toctree-l1"><a class="reference internal" href="5.html">5. The kvm_run structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="6.html">6. Capabilities that can be enabled on vCPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="7.html">7. Capabilities that can be enabled on VMs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Other capabilities.</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-ppc-hwrng">8.1 KVM_CAP_PPC_HWRNG</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-hyperv-synic">8.2 KVM_CAP_HYPERV_SYNIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-ppc-radix-mmu">8.3 KVM_CAP_PPC_RADIX_MMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-ppc-hash-mmu-v3">8.4 KVM_CAP_PPC_HASH_MMU_V3</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-mips-vz">8.5 KVM_CAP_MIPS_VZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-mips-te">8.6 KVM_CAP_MIPS_TE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-mips-64bit">8.7 KVM_CAP_MIPS_64BIT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-arm-user-irq">8.9 KVM_CAP_ARM_USER_IRQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-ppc-smt-possible">8.10 KVM_CAP_PPC_SMT_POSSIBLE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-hyperv-synic2">8.11 KVM_CAP_HYPERV_SYNIC2</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-hyperv-vp-index">8.12 KVM_CAP_HYPERV_VP_INDEX</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-s390-ais-migration">8.13 KVM_CAP_S390_AIS_MIGRATION</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-s390-psw">8.14 KVM_CAP_S390_PSW</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-s390-gmap">8.15 KVM_CAP_S390_GMAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-s390-cow">8.16 KVM_CAP_S390_COW</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-s390-bpb">8.17 KVM_CAP_S390_BPB</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-hyperv-tlbflush">8.18 KVM_CAP_HYPERV_TLBFLUSH</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-arm-inject-serror-esr">8.19 KVM_CAP_ARM_INJECT_SERROR_ESR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-hyperv-send-ipi">8.20 KVM_CAP_HYPERV_SEND_IPI</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux KVM</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>8. Other capabilities.</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/8.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="other-capabilities">
<h1>8. Other capabilities.<a class="headerlink" href="#other-capabilities" title="Permalink to this headline">¶</a></h1>
<p>This section lists capabilities that give information about other
features of the KVM implementation.</p>
<div class="section" id="kvm-cap-ppc-hwrng">
<h2>8.1 KVM_CAP_PPC_HWRNG<a class="headerlink" href="#kvm-cap-ppc-hwrng" title="Permalink to this headline">¶</a></h2>
<p>Architectures: ppc</p>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that that the kernel has an implementation of the
H_RANDOM hypercall backed by a hardware random-number generator.
If present, the kernel H_RANDOM handler can be enabled for guest use
with the KVM_CAP_PPC_ENABLE_HCALL capability.</p>
</div>
<div class="section" id="kvm-cap-hyperv-synic">
<h2>8.2 KVM_CAP_HYPERV_SYNIC<a class="headerlink" href="#kvm-cap-hyperv-synic" title="Permalink to this headline">¶</a></h2>
<p>Architectures: x86
This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that that the kernel has an implementation of the
Hyper-V Synthetic interrupt controller(SynIC). Hyper-V SynIC is
used to support Windows Hyper-V based guest paravirt drivers(VMBus).</p>
<p>In order to use SynIC, it has to be activated by setting this
capability via KVM_ENABLE_CAP ioctl on the vcpu fd. Note that this
will disable the use of APIC hardware virtualization even if supported
by the CPU, as it’s incompatible with SynIC auto-EOI behavior.</p>
</div>
<div class="section" id="kvm-cap-ppc-radix-mmu">
<h2>8.3 KVM_CAP_PPC_RADIX_MMU<a class="headerlink" href="#kvm-cap-ppc-radix-mmu" title="Permalink to this headline">¶</a></h2>
<p>Architectures: ppc</p>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that that the kernel can support guests using the
radix MMU defined in Power ISA V3.00 (as implemented in the POWER9
processor).</p>
</div>
<div class="section" id="kvm-cap-ppc-hash-mmu-v3">
<h2>8.4 KVM_CAP_PPC_HASH_MMU_V3<a class="headerlink" href="#kvm-cap-ppc-hash-mmu-v3" title="Permalink to this headline">¶</a></h2>
<p>Architectures: ppc</p>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that that the kernel can support guests using the
hashed page table MMU defined in Power ISA V3.00 (as implemented in
the POWER9 processor), including in-memory segment tables.</p>
</div>
<div class="section" id="kvm-cap-mips-vz">
<h2>8.5 KVM_CAP_MIPS_VZ<a class="headerlink" href="#kvm-cap-mips-vz" title="Permalink to this headline">¶</a></h2>
<p>Architectures: mips</p>
<p>This capability, if KVM_CHECK_EXTENSION on the main kvm handle indicates that
it is available, means that full hardware assisted virtualization capabilities
of the hardware are available for use through KVM. An appropriate
KVM_VM_MIPS_* type must be passed to KVM_CREATE_VM to create a VM which
utilises it.</p>
<p>If KVM_CHECK_EXTENSION on a kvm VM handle indicates that this capability is
available, it means that the VM is using full hardware assisted virtualization
capabilities of the hardware. This is useful to check after creating a VM with
KVM_VM_MIPS_DEFAULT.</p>
<p>The value returned by KVM_CHECK_EXTENSION should be compared against known
values (see below). All other values are reserved. This is to allow for the
possibility of other hardware assisted virtualization implementations which
may be incompatible with the MIPS VZ ASE.</p>
<blockquote>
<div><dl class="simple">
<dt>0: The trap &amp; emulate implementation is in use to run guest code in user</dt><dd><p>mode. Guest virtual memory segments are rearranged to fit the guest in the
user mode address space.</p>
</dd>
<dt>1: The MIPS VZ ASE is in use, providing full hardware assisted</dt><dd><p>virtualization, including standard guest virtual memory segments.</p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="kvm-cap-mips-te">
<h2>8.6 KVM_CAP_MIPS_TE<a class="headerlink" href="#kvm-cap-mips-te" title="Permalink to this headline">¶</a></h2>
<p>Architectures: mips</p>
<p>This capability, if KVM_CHECK_EXTENSION on the main kvm handle indicates that
it is available, means that the trap &amp; emulate implementation is available to
run guest code in user mode, even if KVM_CAP_MIPS_VZ indicates that hardware
assisted virtualisation is also available. KVM_VM_MIPS_TE (0) must be passed
to KVM_CREATE_VM to create a VM which utilises it.</p>
<p>If KVM_CHECK_EXTENSION on a kvm VM handle indicates that this capability is
available, it means that the VM is using trap &amp; emulate.</p>
</div>
<div class="section" id="kvm-cap-mips-64bit">
<h2>8.7 KVM_CAP_MIPS_64BIT<a class="headerlink" href="#kvm-cap-mips-64bit" title="Permalink to this headline">¶</a></h2>
<p>Architectures: mips</p>
<p>This capability indicates the supported architecture type of the guest, i.e. the
supported register and address width.</p>
<p>The values returned when this capability is checked by KVM_CHECK_EXTENSION on a
kvm VM handle correspond roughly to the CP0_Config.AT register field, and should
be checked specifically against known values (see below). All other values are
reserved.</p>
<blockquote>
<div><dl class="simple">
<dt>0: MIPS32 or microMIPS32.</dt><dd><p>Both registers and addresses are 32-bits wide.
It will only be possible to run 32-bit guest code.</p>
</dd>
<dt>1: MIPS64 or microMIPS64 with access only to 32-bit compatibility segments.</dt><dd><p>Registers are 64-bits wide, but addresses are 32-bits wide.
64-bit guest code may run but cannot access MIPS64 memory segments.
It will also be possible to run 32-bit guest code.</p>
</dd>
<dt>2: MIPS64 or microMIPS64 with access to all address segments.</dt><dd><p>Both registers and addresses are 64-bits wide.
It will be possible to run 64-bit or 32-bit guest code.</p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="kvm-cap-arm-user-irq">
<h2>8.9 KVM_CAP_ARM_USER_IRQ<a class="headerlink" href="#kvm-cap-arm-user-irq" title="Permalink to this headline">¶</a></h2>
<p>Architectures: arm, arm64
This capability, if KVM_CHECK_EXTENSION indicates that it is available, means
that if userspace creates a VM without an in-kernel interrupt controller, it
will be notified of changes to the output level of in-kernel emulated devices,
which can generate virtual interrupts, presented to the VM.
For such VMs, on every return to userspace, the kernel
updates the vcpu’s run-&gt;s.regs.device_irq_level field to represent the actual
output level of the device.</p>
<p>Whenever kvm detects a change in the device output level, kvm guarantees at
least one return to userspace before running the VM.  This exit could either
be a KVM_EXIT_INTR or any other exit event, like KVM_EXIT_MMIO. This way,
userspace can always sample the device output level and re-compute the state of
the userspace interrupt controller.  Userspace should always check the state
of run-&gt;s.regs.device_irq_level on every kvm exit.
The value in run-&gt;s.regs.device_irq_level can represent both level and edge
triggered interrupt signals, depending on the device.  Edge triggered interrupt
signals will exit to userspace with the bit in run-&gt;s.regs.device_irq_level
set exactly once per edge signal.</p>
<p>The field run-&gt;s.regs.device_irq_level is available independent of
run-&gt;kvm_valid_regs or run-&gt;kvm_dirty_regs bits.</p>
<p>If KVM_CAP_ARM_USER_IRQ is supported, the KVM_CHECK_EXTENSION ioctl returns a
number larger than 0 indicating the version of this capability is implemented
and thereby which bits in in run-&gt;s.regs.device_irq_level can signal values.</p>
<p>Currently the following bits are defined for the device_irq_level bitmap:</p>
<blockquote>
<div><p>KVM_CAP_ARM_USER_IRQ &gt;= 1:</p>
<blockquote>
<div><p>KVM_ARM_DEV_EL1_VTIMER -  EL1 virtual timer
KVM_ARM_DEV_EL1_PTIMER -  EL1 physical timer
KVM_ARM_DEV_PMU        -  ARM PMU overflow interrupt signal</p>
</div></blockquote>
</div></blockquote>
<p>Future versions of kvm may implement additional events. These will get
indicated by returning a higher number from KVM_CHECK_EXTENSION and will be
listed above.</p>
</div>
<div class="section" id="kvm-cap-ppc-smt-possible">
<h2>8.10 KVM_CAP_PPC_SMT_POSSIBLE<a class="headerlink" href="#kvm-cap-ppc-smt-possible" title="Permalink to this headline">¶</a></h2>
<p>Architectures: ppc</p>
<p>Querying this capability returns a bitmap indicating the possible
virtual SMT modes that can be set using KVM_CAP_PPC_SMT.  If bit N
(counting from the right) is set, then a virtual SMT mode of 2^N is
available.</p>
</div>
<div class="section" id="kvm-cap-hyperv-synic2">
<h2>8.11 KVM_CAP_HYPERV_SYNIC2<a class="headerlink" href="#kvm-cap-hyperv-synic2" title="Permalink to this headline">¶</a></h2>
<p>Architectures: x86</p>
<p>This capability enables a newer version of Hyper-V Synthetic interrupt
controller (SynIC).  The only difference with KVM_CAP_HYPERV_SYNIC is that KVM
doesn’t clear SynIC message and event flags pages when they are enabled by
writing to the respective MSRs.</p>
</div>
<div class="section" id="kvm-cap-hyperv-vp-index">
<h2>8.12 KVM_CAP_HYPERV_VP_INDEX<a class="headerlink" href="#kvm-cap-hyperv-vp-index" title="Permalink to this headline">¶</a></h2>
<p>Architectures: x86</p>
<p>This capability indicates that userspace can load HV_X64_MSR_VP_INDEX msr.  Its
value is used to denote the target vcpu for a SynIC interrupt.  For
compatibilty, KVM initializes this msr to KVM’s internal vcpu index.  When this
capability is absent, userspace can still query this msr’s value.</p>
</div>
<div class="section" id="kvm-cap-s390-ais-migration">
<h2>8.13 KVM_CAP_S390_AIS_MIGRATION<a class="headerlink" href="#kvm-cap-s390-ais-migration" title="Permalink to this headline">¶</a></h2>
<p>Architectures: s390
Parameters: none</p>
<p>This capability indicates if the flic device will be able to get/set the
AIS states for migration via the KVM_DEV_FLIC_AISM_ALL attribute and allows
to discover this without having to create a flic device.</p>
</div>
<div class="section" id="kvm-cap-s390-psw">
<h2>8.14 KVM_CAP_S390_PSW<a class="headerlink" href="#kvm-cap-s390-psw" title="Permalink to this headline">¶</a></h2>
<p>Architectures: s390</p>
<p>This capability indicates that the PSW is exposed via the kvm_run structure.</p>
</div>
<div class="section" id="kvm-cap-s390-gmap">
<h2>8.15 KVM_CAP_S390_GMAP<a class="headerlink" href="#kvm-cap-s390-gmap" title="Permalink to this headline">¶</a></h2>
<p>Architectures: s390</p>
<p>This capability indicates that the user space memory used as guest mapping can
be anywhere in the user memory address space, as long as the memory slots are
aligned and sized to a segment (1MB) boundary.</p>
</div>
<div class="section" id="kvm-cap-s390-cow">
<h2>8.16 KVM_CAP_S390_COW<a class="headerlink" href="#kvm-cap-s390-cow" title="Permalink to this headline">¶</a></h2>
<p>Architectures: s390</p>
<p>This capability indicates that the user space memory used as guest mapping can
use copy-on-write semantics as well as dirty pages tracking via read-only page
tables.</p>
</div>
<div class="section" id="kvm-cap-s390-bpb">
<h2>8.17 KVM_CAP_S390_BPB<a class="headerlink" href="#kvm-cap-s390-bpb" title="Permalink to this headline">¶</a></h2>
<p>Architectures: s390</p>
<p>This capability indicates that kvm will implement the interfaces to handle
reset, migration and nested KVM for branch prediction blocking. The stfle
facility 82 should not be provided to the guest without this capability.</p>
</div>
<div class="section" id="kvm-cap-hyperv-tlbflush">
<h2>8.18 KVM_CAP_HYPERV_TLBFLUSH<a class="headerlink" href="#kvm-cap-hyperv-tlbflush" title="Permalink to this headline">¶</a></h2>
<p>Architectures: x86</p>
<p>This capability indicates that KVM supports paravirtualized Hyper-V TLB Flush
hypercalls:
HvFlushVirtualAddressSpace, HvFlushVirtualAddressSpaceEx,
HvFlushVirtualAddressList, HvFlushVirtualAddressListEx.</p>
</div>
<div class="section" id="kvm-cap-arm-inject-serror-esr">
<h2>8.19 KVM_CAP_ARM_INJECT_SERROR_ESR<a class="headerlink" href="#kvm-cap-arm-inject-serror-esr" title="Permalink to this headline">¶</a></h2>
<p>Architectures: arm, arm64</p>
<p>This capability indicates that userspace can specify (via the
KVM_SET_VCPU_EVENTS ioctl) the syndrome value reported to the guest when it
takes a virtual SError interrupt exception.
If KVM advertises this capability, userspace can only specify the ISS field for
the ESR syndrome. Other parts of the ESR, such as the EC are generated by the
CPU when the exception is taken. If this virtual SError is taken to EL1 using
AArch64, this value will be reported in the ISS field of ESR_ELx.</p>
<p>See KVM_CAP_VCPU_EVENTS for more details.</p>
</div>
<div class="section" id="kvm-cap-hyperv-send-ipi">
<h2>8.20 KVM_CAP_HYPERV_SEND_IPI<a class="headerlink" href="#kvm-cap-hyperv-send-ipi" title="Permalink to this headline">¶</a></h2>
<p>Architectures: x86</p>
<p>This capability indicates that KVM supports paravirtualized Hyper-V IPI send
hypercalls:
HvCallSendSyntheticClusterIpi, HvCallSendSyntheticClusterIpiEx.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="7.html" class="btn btn-neutral float-left" title="7. Capabilities that can be enabled on VMs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Takumi Takahashi

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-62539992-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>