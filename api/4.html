

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. API description &mdash; Linux KVM  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. The kvm_run structure" href="5.html" />
    <link rel="prev" title="3. Extensions" href="3.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Linux KVM
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table Of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1.html">1. General description</a></li>
<li class="toctree-l1"><a class="reference internal" href="2.html">2. File descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="3.html">3. Extensions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. API description</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-api-version">4.1 KVM_GET_API_VERSION</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-create-vm">4.2 KVM_CREATE_VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-msr-index-list-kvm-get-msr-feature-index-list">4.3 KVM_GET_MSR_INDEX_LIST, KVM_GET_MSR_FEATURE_INDEX_LIST</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-check-extension">4.4 KVM_CHECK_EXTENSION</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-vcpu-mmap-size">4.5 KVM_GET_VCPU_MMAP_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-memory-region">4.6 KVM_SET_MEMORY_REGION</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-create-vcpu">4.7 KVM_CREATE_VCPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-dirty-log-vm-ioctl">4.8 KVM_GET_DIRTY_LOG (vm ioctl)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-memory-alias">4.9 KVM_SET_MEMORY_ALIAS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-run">4.10 KVM_RUN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-regs">4.11 KVM_GET_REGS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-regs">4.12 KVM_SET_REGS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-sregs">4.13 KVM_GET_SREGS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-sregs">4.14 KVM_SET_SREGS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-translate">4.15 KVM_TRANSLATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-interrupt">4.16 KVM_INTERRUPT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-debug-guest">4.17 KVM_DEBUG_GUEST</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-msrs">4.18 KVM_GET_MSRS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-msrs">4.19 KVM_SET_MSRS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-cpuid">4.20 KVM_SET_CPUID</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-signal-mask">4.21 KVM_SET_SIGNAL_MASK</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-fpu">4.22 KVM_GET_FPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-fpu">4.23 KVM_SET_FPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-create-irqchip">4.24 KVM_CREATE_IRQCHIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-irq-line">4.25 KVM_IRQ_LINE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-irqchip">4.26 KVM_GET_IRQCHIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-irqchip">4.27 KVM_SET_IRQCHIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-xen-hvm-config">4.28 KVM_XEN_HVM_CONFIG</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-clock">4.29 KVM_GET_CLOCK</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-clock">4.30 KVM_SET_CLOCK</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-vcpu-events">4.31 KVM_GET_VCPU_EVENTS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-vcpu-events">4.32 KVM_SET_VCPU_EVENTS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-debugregs">4.33 KVM_GET_DEBUGREGS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-debugregs">4.34 KVM_SET_DEBUGREGS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-user-memory-region">4.35 KVM_SET_USER_MEMORY_REGION</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-tss-addr">4.36 KVM_SET_TSS_ADDR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-enable-cap">4.37 KVM_ENABLE_CAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-mp-state">4.38 KVM_GET_MP_STATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-mp-state">4.39 KVM_SET_MP_STATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-identity-map-addr">4.40 KVM_SET_IDENTITY_MAP_ADDR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-boot-cpu-id">4.41 KVM_SET_BOOT_CPU_ID</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-xsave">4.42 KVM_GET_XSAVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-xsave">4.43 KVM_SET_XSAVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-xcrs">4.44 KVM_GET_XCRS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-xcrs">4.45 KVM_SET_XCRS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-supported-cpuid">4.46 KVM_GET_SUPPORTED_CPUID</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-get-pvinfo">4.47 KVM_PPC_GET_PVINFO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-gsi-routing">4.52 KVM_SET_GSI_ROUTING</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-tsc-khz">4.55 KVM_SET_TSC_KHZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-tsc-khz">4.56 KVM_GET_TSC_KHZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-lapic">4.57 KVM_GET_LAPIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-lapic">4.58 KVM_SET_LAPIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ioeventfd">4.59 KVM_IOEVENTFD</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-dirty-tlb">4.60 KVM_DIRTY_TLB</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-create-spapr-tce">4.62 KVM_CREATE_SPAPR_TCE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-allocate-rma">4.63 KVM_ALLOCATE_RMA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-nmi">4.64 KVM_NMI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-ucas-map">4.65 KVM_S390_UCAS_MAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-ucas-unmap">4.66 KVM_S390_UCAS_UNMAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-vcpu-fault">4.67 KVM_S390_VCPU_FAULT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-one-reg">4.68 KVM_SET_ONE_REG</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-one-reg">4.69 KVM_GET_ONE_REG</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-kvmclock-ctrl">4.70 KVM_KVMCLOCK_CTRL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-signal-msi">4.71 KVM_SIGNAL_MSI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-create-pit2">4.71 KVM_CREATE_PIT2</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-pit2">4.72 KVM_GET_PIT2</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-pit2">4.73 KVM_SET_PIT2</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-get-smmu-info">4.74 KVM_PPC_GET_SMMU_INFO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-irqfd">4.75 KVM_IRQFD</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-allocate-htab">4.76 KVM_PPC_ALLOCATE_HTAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-interrupt">4.77 KVM_S390_INTERRUPT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-get-htab-fd">4.78 KVM_PPC_GET_HTAB_FD</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-create-device">4.79 KVM_CREATE_DEVICE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-device-attr-kvm-get-device-attr">4.80 KVM_SET_DEVICE_ATTR/KVM_GET_DEVICE_ATTR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-has-device-attr">4.81 KVM_HAS_DEVICE_ATTR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-arm-vcpu-init">4.82 KVM_ARM_VCPU_INIT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-arm-preferred-target">4.83 KVM_ARM_PREFERRED_TARGET</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-reg-list">4.84 KVM_GET_REG_LIST</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-arm-set-device-addr-deprecated">4.85 KVM_ARM_SET_DEVICE_ADDR (deprecated)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-rtas-define-token">4.86 KVM_PPC_RTAS_DEFINE_TOKEN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-guest-debug">4.87 KVM_SET_GUEST_DEBUG</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-emulated-cpuid">4.88 KVM_GET_EMULATED_CPUID</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-mem-op">4.89 KVM_S390_MEM_OP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-get-skeys">4.90 KVM_S390_GET_SKEYS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-set-skeys">4.91 KVM_S390_SET_SKEYS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-irq">4.92 KVM_S390_IRQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-get-irq-state">4.94 KVM_S390_GET_IRQ_STATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-set-irq-state">4.95 KVM_S390_SET_IRQ_STATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-smi">4.96 KVM_SMI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-cap-ppc-multitce">4.97 KVM_CAP_PPC_MULTITCE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-create-spapr-tce-64">4.98 KVM_CREATE_SPAPR_TCE_64</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-reinject-control">4.99 KVM_REINJECT_CONTROL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-configure-v3-mmu">4.100 KVM_PPC_CONFIGURE_V3_MMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-get-rmmu-info">4.101 KVM_PPC_GET_RMMU_INFO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-resize-hpt-prepare">4.102 KVM_PPC_RESIZE_HPT_PREPARE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-resize-hpt-commit">4.103 KVM_PPC_RESIZE_HPT_COMMIT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-x86-get-mce-cap-supported">4.104 KVM_X86_GET_MCE_CAP_SUPPORTED</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-x86-setup-mce">4.105 KVM_X86_SETUP_MCE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-x86-set-mce">4.106 KVM_X86_SET_MCE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-get-cmma-bits">4.107 KVM_S390_GET_CMMA_BITS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-s390-set-cmma-bits">4.108 KVM_S390_SET_CMMA_BITS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-ppc-get-cpu-char">4.109 KVM_PPC_GET_CPU_CHAR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-memory-encrypt-op">4.110 KVM_MEMORY_ENCRYPT_OP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-memory-encrypt-reg-region">4.111 KVM_MEMORY_ENCRYPT_REG_REGION</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-memory-encrypt-unreg-region">4.112 KVM_MEMORY_ENCRYPT_UNREG_REGION</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-hyperv-eventfd">4.113 KVM_HYPERV_EVENTFD</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-nested-state">4.114 KVM_GET_NESTED_STATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-set-nested-state">4.115 KVM_SET_NESTED_STATE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-un-register-coalesced-mmio">4.116 KVM_(UN)REGISTER_COALESCED_MMIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-clear-dirty-log-vm-ioctl">4.117 KVM_CLEAR_DIRTY_LOG (vm ioctl)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kvm-get-supported-hv-cpuid">4.118 KVM_GET_SUPPORTED_HV_CPUID</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5.html">5. The kvm_run structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="6.html">6. Capabilities that can be enabled on vCPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="7.html">7. Capabilities that can be enabled on VMs</a></li>
<li class="toctree-l1"><a class="reference internal" href="8.html">8. Other capabilities.</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux KVM</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>4. API description</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/4.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-description">
<h1>4. API description<a class="headerlink" href="#api-description" title="Permalink to this headline">¶</a></h1>
<p>This section describes ioctls that can be used to control kvm guests.
For each ioctl, the following information is provided along with a
description:</p>
<dl class="simple">
<dt>Capability</dt><dd><p>which KVM extension provides this ioctl.  Can be ‘basic’,
which means that is will be provided by any kernel that supports
API version 12 (see section 4.1), a KVM_CAP_xyz constant, which
means availability needs to be checked with KVM_CHECK_EXTENSION
(see section 4.4), or ‘none’ which means that while not all kernels
support this ioctl, there’s no capability bit to check its
availability: for kernels that don’t support the ioctl,
the ioctl returns -ENOTTY.</p>
</dd>
<dt>Architectures</dt><dd><p>which instruction set architectures provide this ioctl.
x86 includes both i386 and x86_64.</p>
</dd>
<dt>Type</dt><dd><p>system, vm, or vcpu.</p>
</dd>
<dt>Parameters</dt><dd><p>what parameters are accepted by the ioctl.</p>
</dd>
<dt>Returns</dt><dd><p>the return value.  General error numbers (EBADF, ENOMEM, EINVAL)
are not detailed, but errors with specific meanings are.</p>
</dd>
</dl>
<div class="section" id="kvm-get-api-version">
<h2>4.1 KVM_GET_API_VERSION<a class="headerlink" href="#kvm-get-api-version" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the constant KVM_API_VERSION (=12)</p>
</dd>
</dl>
<p>This identifies the API version as the stable kvm API. It is not
expected that this number will change.  However, Linux 2.6.20 and
2.6.21 report earlier versions; these are not documented and not
supported.  Applications should refuse to run if KVM_GET_API_VERSION
returns a value other than 12.  If this check passes, all ioctls
described as ‘basic’ will be available.</p>
</div>
<div class="section" id="kvm-create-vm">
<h2>4.2 KVM_CREATE_VM<a class="headerlink" href="#kvm-create-vm" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>machine type identifier (KVM_VM_*)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a VM fd that can be used to control the new virtual machine.</p>
</dd>
</dl>
<p>The new VM has no virtual cpus and no memory.
You probably want to use 0 as machine type.</p>
<p>In order to create user controlled virtual machines on S390, check
KVM_CAP_S390_UCONTROL and use the flag KVM_VM_S390_UCONTROL as
privileged user (CAP_SYS_ADMIN).</p>
<p>To use hardware assisted virtualization on MIPS (VZ ASE) rather than
the default trap &amp; emulate implementation (which changes the virtual
memory layout to fit in user mode), check KVM_CAP_MIPS_VZ and use the
flag KVM_VM_MIPS_VZ.</p>
<p>On arm64, the physical address size for a VM (IPA Size limit) is limited
to 40bits by default. The limit can be configured if the host supports the
extension KVM_CAP_ARM_VM_IPA_SIZE. When supported, use
KVM_VM_TYPE_ARM_IPA_SIZE(IPA_Bits) to set the size in the machine type
identifier, where IPA_Bits is the maximum width of any physical
address used by the VM. The IPA_Bits is encoded in bits[7-0] of the
machine type identifier.</p>
<p>e.g, to configure a guest to use 48bit physical address size:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vm_fd</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">dev_fd</span><span class="p">,</span> <span class="n">KVM_CREATE_VM</span><span class="p">,</span> <span class="n">KVM_VM_TYPE_ARM_IPA_SIZE</span><span class="p">(</span><span class="mi">48</span><span class="p">));</span>
</pre></div>
</div>
<p>The requested size (IPA_Bits) must be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">-</span> <span class="n">Implies</span> <span class="n">default</span> <span class="n">size</span><span class="p">,</span> <span class="mi">40</span><span class="n">bits</span> <span class="p">(</span><span class="k">for</span> <span class="n">backward</span> <span class="n">compatibility</span><span class="p">)</span>

<span class="ow">or</span>

<span class="n">N</span> <span class="o">-</span> <span class="n">Implies</span> <span class="n">N</span> <span class="n">bits</span><span class="p">,</span> <span class="n">where</span> <span class="n">N</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">positive</span> <span class="n">integer</span> <span class="n">such</span> <span class="n">that</span><span class="p">,</span>
   <span class="mi">32</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="n">Host_IPA_Limit</span>
</pre></div>
</div>
<p>Host_IPA_Limit is the maximum possible value for IPA_Bits on the host and
is dependent on the CPU capability and the kernel configuration. The limit can
be retrieved using KVM_CAP_ARM_VM_IPA_SIZE of the KVM_CHECK_EXTENSION
ioctl() at run-time.</p>
<p>Please note that configuring the IPA size does not affect the capability
exposed by the guest CPUs in ID_AA64MMFR0_EL1[PARange]. It only affects
size of the address translated by the stage2 level (guest physical to
host physical address translations).</p>
</div>
<div class="section" id="kvm-get-msr-index-list-kvm-get-msr-feature-index-list">
<h2>4.3 KVM_GET_MSR_INDEX_LIST, KVM_GET_MSR_FEATURE_INDEX_LIST<a class="headerlink" href="#kvm-get-msr-index-list-kvm-get-msr-feature-index-list" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic, KVM_CAP_GET_MSR_FEATURES for KVM_GET_MSR_FEATURE_INDEX_LIST</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msr_list (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
<dt class="field-even">Errors</dt>
<dd class="field-even"><ul class="simple">
<li><p>EFAULT : the msr index list cannot be read from or written to</p></li>
<li><p>E2BIG : the msr index list is to be to fit in the array
specified by the user.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_msr_list</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nmsrs</span><span class="p">;</span> <span class="cm">/* number of msrs in entries */</span>
        <span class="n">__u32</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The user fills in the size of the indices array in nmsrs, and in return
kvm adjusts nmsrs to reflect the actual number of msrs and fills in the
indices array with their numbers.</p>
<p>KVM_GET_MSR_INDEX_LIST returns the guest msrs that are supported.  The list
varies by kvm version and host processor, but does not change otherwise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if kvm indicates supports MCE (KVM_CAP_MCE), then the MCE bank MSRs are
not returned in the MSR list, as different vcpus can have a different number
of banks, as set via the KVM_X86_SETUP_MCE ioctl.</p>
</div>
<p>KVM_GET_MSR_FEATURE_INDEX_LIST returns the list of MSRs that can be passed
to the KVM_GET_MSRS system ioctl.  This lets userspace probe host capabilities
and processor features that are exposed via MSRs (e.g., VMX capabilities).
This list also varies by kvm version and host processor, but does not change
otherwise.</p>
</div>
<div class="section" id="kvm-check-extension">
<h2>4.4 KVM_CHECK_EXTENSION<a class="headerlink" href="#kvm-check-extension" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic, KVM_CAP_CHECK_EXTENSION_VM for vm ioctl</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl, vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>extension identifier (KVM_CAP_*)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 if unsupported</p></li>
<li><p>1 (or some other positive integer) if supported</p></li>
</ul>
</dd>
</dl>
<p>The API allows the application to query about extensions to the core
kvm API.  Userspace passes an extension identifier (an integer) and
receives an integer that describes the extension availability.
Generally 0 means no and 1 means yes, but some extensions may report
additional information in the integer return value.</p>
<p>Based on their initialization different VMs may have different capabilities.
It is thus encouraged to use the vm ioctl to query for capabilities (available
with KVM_CAP_CHECK_EXTENSION_VM on the vm fd)</p>
</div>
<div class="section" id="kvm-get-vcpu-mmap-size">
<h2>4.5 KVM_GET_VCPU_MMAP_SIZE<a class="headerlink" href="#kvm-get-vcpu-mmap-size" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>size of vcpu mmap area, in bytes</p>
</dd>
</dl>
<p>The KVM_RUN ioctl (cf.) communicates with userspace via a shared
memory region.  This ioctl returns the size of that region.  See the
KVM_RUN documentation for details.</p>
</div>
<div class="section" id="kvm-set-memory-region">
<h2>4.6 KVM_SET_MEMORY_REGION<a class="headerlink" href="#kvm-set-memory-region" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_memory_region (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>This ioctl is obsolete and has been removed.</p>
</div>
<div class="section" id="kvm-create-vcpu">
<h2>4.7 KVM_CREATE_VCPU<a class="headerlink" href="#kvm-create-vcpu" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>vcpu id (apic id on x86)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>vcpu fd on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>This API adds a vcpu to a virtual machine. No more than max_vcpus may be added.
The vcpu id is an integer in the range [0, max_vcpu_id).</p>
<p>The recommended max_vcpus value can be retrieved using the KVM_CAP_NR_VCPUS of
the KVM_CHECK_EXTENSION ioctl() at run-time.
The maximum possible value for max_vcpus can be retrieved using the
KVM_CAP_MAX_VCPUS of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_NR_VCPUS does not exist, you should assume that max_vcpus is 4
cpus max.
If the KVM_CAP_MAX_VCPUS does not exist, you should assume that max_vcpus is
same as the value returned from KVM_CAP_NR_VCPUS.</p>
<p>The maximum possible value for max_vcpu_id can be retrieved using the
KVM_CAP_MAX_VCPU_ID of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_MAX_VCPU_ID does not exist, you should assume that max_vcpu_id
is the same as the value returned from KVM_CAP_MAX_VCPUS.</p>
<p>On powerpc using book3s_hv mode, the vcpus are mapped onto virtual
threads in one or more virtual CPU cores.  (This is because the
hardware requires all the hardware threads in a CPU core to be in the
same partition.)  The KVM_CAP_PPC_SMT capability indicates the number
of vcpus per virtual core (vcore).  The vcore id is obtained by
dividing the vcpu id by the number of vcpus per vcore.  The vcpus in a
given vcore will always be in the same physical core as each other
(though that might be a different physical core from time to time).
Userspace can control the threading (SMT) mode of the guest by its
allocation of vcpu ids.  For example, if userspace wants
single-threaded guest vcpus, it should make all vcpu ids be a multiple
of the number of vcpus per vcore.</p>
<p>For virtual cpus that have been created with S390 user controlled virtual
machines, the resulting vcpu fd can be memory mapped at page offset
KVM_S390_SIE_PAGE_OFFSET in order to obtain a memory map of the virtual
cpu’s hardware control block.</p>
</div>
<div class="section" id="kvm-get-dirty-log-vm-ioctl">
<h2>4.8 KVM_GET_DIRTY_LOG (vm ioctl)<a class="headerlink" href="#kvm-get-dirty-log-vm-ioctl" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_dirty_log (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_GET_DIRTY_LOG */</span>
<span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">slot</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span> <span class="cm">/* one bit per page */</span>
                <span class="n">__u64</span> <span class="n">padding</span><span class="p">;</span>
        <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Given a memory slot, return a bitmap containing any pages dirtied
since the last call to this ioctl.  Bit 0 is the first page in the
memory slot.  Ensure the entire structure is cleared to avoid padding
issues.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 specifies
the address space for which you want to return the dirty bitmap.
They must be less than the value that KVM_CHECK_EXTENSION returns for
the KVM_CAP_MULTI_ADDRESS_SPACE capability.</p>
<p>The bits in the dirty bitmap are cleared before the ioctl returns, unless
KVM_CAP_MANUAL_DIRTY_LOG_PROTECT is enabled.  For more information,
see the description of the capability.</p>
</div>
<div class="section" id="kvm-set-memory-alias">
<h2>4.9 KVM_SET_MEMORY_ALIAS<a class="headerlink" href="#kvm-set-memory-alias" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_memory_alias (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 (success), -1 (error)</p>
</dd>
</dl>
<p>This ioctl is obsolete and has been removed.</p>
</div>
<div class="section" id="kvm-run">
<h2>4.10 KVM_RUN<a class="headerlink" href="#kvm-run" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
<dt class="field-even">Errors</dt>
<dd class="field-even"><dl class="field-list simple">
<dt class="field-odd">EINTR</dt>
<dd class="field-odd"><p>an unmasked signal is pending</p>
</dd>
</dl>
</dd>
</dl>
<p>This ioctl is used to run a guest virtual cpu.  While there are no
explicit parameters, there is an implicit parameter block that can be
obtained by mmap()ing the vcpu fd at offset 0, with the size given by
KVM_GET_VCPU_MMAP_SIZE.  The parameter block is formatted as a ‘struct
kvm_run’ (see below).</p>
</div>
<div class="section" id="kvm-get-regs">
<h2>4.11 KVM_GET_REGS<a class="headerlink" href="#kvm-get-regs" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all except ARM, arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_regs (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Reads the general purpose registers from the vcpu.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* x86 */</span>
<span class="k">struct</span> <span class="n">kvm_regs</span> <span class="p">{</span>
        <span class="cm">/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */</span>
        <span class="n">__u64</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span><span class="p">,</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">rdx</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">rsi</span><span class="p">,</span> <span class="n">rdi</span><span class="p">,</span> <span class="n">rsp</span><span class="p">,</span> <span class="n">rbp</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">r8</span><span class="p">,</span>  <span class="n">r9</span><span class="p">,</span>  <span class="n">r10</span><span class="p">,</span> <span class="n">r11</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">r12</span><span class="p">,</span> <span class="n">r13</span><span class="p">,</span> <span class="n">r14</span><span class="p">,</span> <span class="n">r15</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">rip</span><span class="p">,</span> <span class="n">rflags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* mips */</span>
<span class="k">struct</span> <span class="n">kvm_regs</span> <span class="p">{</span>
        <span class="cm">/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */</span>
        <span class="n">__u64</span> <span class="n">gpr</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
        <span class="n">__u64</span> <span class="n">hi</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">lo</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-regs">
<h2>4.12 KVM_SET_REGS<a class="headerlink" href="#kvm-set-regs" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all except ARM, arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_regs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Writes the general purpose registers into the vcpu.</p>
<p>See KVM_GET_REGS for the data structure.</p>
</div>
<div class="section" id="kvm-get-sregs">
<h2>4.13 KVM_GET_SREGS<a class="headerlink" href="#kvm-get-sregs" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_sregs (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Reads special registers from the vcpu.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* x86 */</span>
<span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">cs</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">gs</span><span class="p">,</span> <span class="n">ss</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">tr</span><span class="p">,</span> <span class="n">ldt</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_dtable</span> <span class="n">gdt</span><span class="p">,</span> <span class="n">idt</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">cr0</span><span class="p">,</span> <span class="n">cr2</span><span class="p">,</span> <span class="n">cr3</span><span class="p">,</span> <span class="n">cr4</span><span class="p">,</span> <span class="n">cr8</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">efer</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">apic_base</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">interrupt_bitmap</span><span class="p">[(</span><span class="n">KVM_NR_INTERRUPTS</span> <span class="o">+</span> <span class="mi">63</span><span class="p">)</span> <span class="o">/</span> <span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* ppc -- see arch/powerpc/include/uapi/asm/kvm.h */</span>
</pre></div>
</div>
<p>interrupt_bitmap is a bitmap of pending external interrupts.  At most
one bit may be set.  This interrupt has been acknowledged by the APIC
but not yet injected into the cpu core.</p>
</div>
<div class="section" id="kvm-set-sregs">
<h2>4.14 KVM_SET_SREGS<a class="headerlink" href="#kvm-set-sregs" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_sregs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Writes special registers into the vcpu.  See KVM_GET_SREGS for the
data structures.</p>
</div>
<div class="section" id="kvm-translate">
<h2>4.15 KVM_TRANSLATE<a class="headerlink" href="#kvm-translate" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_translation (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Translates a virtual address according to the vcpu’s current address
translation mode.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_translation</span> <span class="p">{</span>
        <span class="cm">/* in */</span>
        <span class="n">__u64</span> <span class="n">linear_address</span><span class="p">;</span>

        <span class="cm">/* out */</span>
        <span class="n">__u64</span> <span class="n">physical_address</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">valid</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">writeable</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">usermode</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">pad</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-interrupt">
<h2>4.16 KVM_INTERRUPT<a class="headerlink" href="#kvm-interrupt" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, ppc, mips</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_interrupt (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>negative on failure.</p></li>
</ul>
</dd>
</dl>
<p>Queues a hardware interrupt vector to be injected.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_INTERRUPT */</span>
<span class="k">struct</span> <span class="n">kvm_interrupt</span> <span class="p">{</span>
        <span class="cm">/* in */</span>
        <span class="n">__u32</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>X86:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success,</p></li>
<li><p>EEXIST if an interrupt is already enqueued</p></li>
<li><p>EINVAL the the irq number is invalid</p></li>
<li><p>ENXIO if the PIC is in the kernel</p></li>
<li><p>EFAULT if the pointer is invalid</p></li>
</ul>
</dd>
</dl>
<p>Note ‘irq’ is an interrupt vector, not an interrupt pin or line. This
ioctl is useful if the in-kernel PIC is not used.</p>
<p>PPC:</p>
<p>Queues an external interrupt to be injected. This ioctl is overleaded
with 3 different irq values:</p>
<ol class="loweralpha simple">
<li><p>KVM_INTERRUPT_SET</p></li>
</ol>
<blockquote>
<div><p>This injects an edge type external interrupt into the guest once it’s ready
to receive interrupts. When injected, the interrupt is done.</p>
</div></blockquote>
<ol class="loweralpha simple" start="2">
<li><p>KVM_INTERRUPT_UNSET</p></li>
</ol>
<blockquote>
<div><p>This unsets any pending interrupt.</p>
<p>Only available with KVM_CAP_PPC_UNSET_IRQ.</p>
</div></blockquote>
<ol class="loweralpha simple" start="3">
<li><p>KVM_INTERRUPT_SET_LEVEL</p></li>
</ol>
<blockquote>
<div><p>This injects a level type external interrupt into the guest context. The
interrupt stays pending until a specific ioctl with KVM_INTERRUPT_UNSET
is triggered.</p>
<p>Only available with KVM_CAP_PPC_IRQ_LEVEL.</p>
</div></blockquote>
<p>Note that any value for ‘irq’ other than the ones stated above is invalid
and incurs unexpected behavior.</p>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
<p>MIPS:</p>
<p>Queues an external interrupt to be injected into the virtual CPU. A negative
interrupt number dequeues the interrupt.</p>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</div>
<div class="section" id="kvm-debug-guest">
<h2>4.17 KVM_DEBUG_GUEST<a class="headerlink" href="#kvm-debug-guest" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>-1 on error</p>
</dd>
</dl>
<p>Support for this has been removed.  Use KVM_SET_GUEST_DEBUG instead.</p>
</div>
<div class="section" id="kvm-get-msrs">
<h2>4.18 KVM_GET_MSRS<a class="headerlink" href="#kvm-get-msrs" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic (vcpu), KVM_CAP_GET_MSR_FEATURES (system)</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl, vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msrs (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>number of msrs successfully returned</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>When used as a system ioctl:</dt><dd><p>Reads the values of MSR-based features that are available for the VM.  This
is similar to KVM_GET_SUPPORTED_CPUID, but it returns MSR indices and values.
The list of msr-based features can be obtained using
KVM_GET_MSR_FEATURE_INDEX_LIST in a system ioctl.</p>
</dd>
<dt>When used as a vcpu ioctl:</dt><dd><p>Reads model-specific registers from the vcpu.  Supported msr indices can
be obtained using KVM_GET_MSR_INDEX_LIST in a system ioctl.</p>
</dd>
</dl>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_msrs</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nmsrs</span><span class="p">;</span> <span class="cm">/* number of msrs in entries */</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">kvm_msr_entry</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_msr_entry</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">index</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Application code should set the ‘nmsrs’ member (which indicates the
size of the entries array) and the ‘index’ member of each array entry.
kvm will fill in the ‘data’ member.</p>
</div>
<div class="section" id="kvm-set-msrs">
<h2>4.19 KVM_SET_MSRS<a class="headerlink" href="#kvm-set-msrs" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msrs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Writes model-specific registers to the vcpu.  See KVM_GET_MSRS for the
data structures.</p>
<p>Application code should set the ‘nmsrs’ member (which indicates the
size of the entries array), and the ‘index’ and ‘data’ members of each
array entry.</p>
</div>
<div class="section" id="kvm-set-cpuid">
<h2>4.20 KVM_SET_CPUID<a class="headerlink" href="#kvm-set-cpuid" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_cpuid (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Defines the vcpu responses to the cpuid instruction.  Applications
should use the KVM_SET_CPUID2 ioctl if available.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_cpuid_entry</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">function</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">eax</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ebx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ecx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">edx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* for KVM_SET_CPUID */</span>
<span class="k">struct</span> <span class="n">kvm_cpuid</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nent</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_cpuid_entry</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-signal-mask">
<h2>4.21 KVM_SET_SIGNAL_MASK<a class="headerlink" href="#kvm-set-signal-mask" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_signal_mask (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Defines which signals are blocked during execution of KVM_RUN.  This
signal mask temporarily overrides the threads signal mask.  Any
unblocked signal received (except SIGKILL and SIGSTOP, which retain
their traditional behaviour) will cause KVM_RUN to return with -EINTR.</p>
<p>Note the signal will only be delivered if not blocked by the original
signal mask.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_SET_SIGNAL_MASK */</span>
<span class="k">struct</span> <span class="n">kvm_signal_mask</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">sigset</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-get-fpu">
<h2>4.22 KVM_GET_FPU<a class="headerlink" href="#kvm-get-fpu" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_fpu (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Reads the floating point state from the vcpu.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_GET_FPU and KVM_SET_FPU */</span>
<span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="p">{</span>
        <span class="n">__u8</span>  <span class="n">fpr</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>
        <span class="n">__u16</span> <span class="n">fcw</span><span class="p">;</span>
        <span class="n">__u16</span> <span class="n">fsw</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">ftwx</span><span class="p">;</span>  <span class="cm">/* in fxsave format */</span>
        <span class="n">__u8</span>  <span class="n">pad1</span><span class="p">;</span>
        <span class="n">__u16</span> <span class="n">last_opcode</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">last_ip</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">last_dp</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">xmm</span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>
        <span class="n">__u32</span> <span class="n">mxcsr</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-fpu">
<h2>4.23 KVM_SET_FPU<a class="headerlink" href="#kvm-set-fpu" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_fpu (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Writes the floating point state to the vcpu.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_GET_FPU and KVM_SET_FPU */</span>
<span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="p">{</span>
        <span class="n">__u8</span>  <span class="n">fpr</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>
        <span class="n">__u16</span> <span class="n">fcw</span><span class="p">;</span>
        <span class="n">__u16</span> <span class="n">fsw</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">ftwx</span><span class="p">;</span>  <span class="cm">/* in fxsave format */</span>
        <span class="n">__u8</span>  <span class="n">pad1</span><span class="p">;</span>
        <span class="n">__u16</span> <span class="n">last_opcode</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">last_ip</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">last_dp</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">xmm</span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>
        <span class="n">__u32</span> <span class="n">mxcsr</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-create-irqchip">
<h2>4.24 KVM_CREATE_IRQCHIP<a class="headerlink" href="#kvm-create-irqchip" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQCHIP, KVM_CAP_S390_IRQCHIP (s390)</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, ARM, arm64, s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p>0 on success</p></li>
<li><p>-1 on error</p></li>
</ul>
</dd>
</dl>
<p>Creates an interrupt controller model in the kernel.
On x86, creates a virtual ioapic, a virtual PIC (two PICs, nested), and sets up
future vcpus to have a local APIC.  IRQ routing for GSIs 0-15 is set to both
PIC and IOAPIC; GSI 16-23 only go to the IOAPIC.
On ARM/arm64, a GICv2 is created. Any other GIC versions require the usage of
KVM_CREATE_DEVICE, which also supports creating a GICv2.  Using
KVM_CREATE_DEVICE is preferred over KVM_CREATE_IRQCHIP for GICv2.
On s390, a dummy irq routing table is created.</p>
<p>Note that on s390 the KVM_CAP_S390_IRQCHIP vm capability needs to be enabled
before KVM_CREATE_IRQCHIP can be used.</p>
</div>
<div class="section" id="kvm-irq-line">
<h2>4.25 KVM_IRQ_LINE<a class="headerlink" href="#kvm-irq-line" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IRQCHIP
Architectures: x86, arm, arm64
Type: vm ioctl
Parameters: struct kvm_irq_level
Returns: 0 on success, -1 on error</p>
<p>Sets the level of a GSI input to the interrupt controller model in the kernel.
On some architectures it is required that an interrupt controller model has
been previously created with KVM_CREATE_IRQCHIP.  Note that edge-triggered
interrupts require the level to be set to 1 and then back to 0.</p>
<p>On real hardware, interrupt pins can be active-low or active-high.  This
does not matter for the level field of struct kvm_irq_level: 1 always
means active (asserted), 0 means inactive (deasserted).</p>
<p>x86 allows the operating system to program the interrupt polarity
(active-low/active-high) for level-triggered interrupts, and KVM used
to consider the polarity.  However, due to bitrot in the handling of
active-low interrupts, the above convention is now valid on x86 too.
This is signaled by KVM_CAP_X86_IOAPIC_POLARITY_IGNORED.  Userspace
should not present interrupts to the guest as active-low unless this
capability is present (or unless it is not using the in-kernel irqchip,
of course).</p>
<p>ARM/arm64 can signal an interrupt either at the CPU level, or at the
in-kernel irqchip (GIC), and for in-kernel irqchip can tell the GIC to
use PPIs designated for specific cpus.  The irq field is interpreted
like this:</p>
<blockquote>
<div><p>bits:  | 31 … 24 | 23  … 16 | 15    …    0 |
field: | irq_type  | vcpu_index |     irq_id     |</p>
</div></blockquote>
<p>The irq_type field has the following values:
- irq_type[0]: out-of-kernel GIC: irq_id 0 is IRQ, irq_id 1 is FIQ
- irq_type[1]: in-kernel GIC: SPI, irq_id between 32 and 1019 (incl.)</p>
<blockquote>
<div><p>(the vcpu_index field is ignored)</p>
</div></blockquote>
<ul class="simple">
<li><p>irq_type[2]: in-kernel GIC: PPI, irq_id between 16 and 31 (incl.)</p></li>
</ul>
<p>(The irq_id field thus corresponds nicely to the IRQ ID in the ARM GIC specs)</p>
<p>In both cases, level is used to assert/deassert the line.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_irq_level</span> <span class="p">{</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="n">__u32</span> <span class="n">irq</span><span class="p">;</span>     <span class="cm">/* GSI */</span>
                <span class="n">__s32</span> <span class="n">status</span><span class="p">;</span>  <span class="cm">/* not used for KVM_IRQ_LEVEL */</span>
        <span class="p">};</span>
        <span class="n">__u32</span> <span class="n">level</span><span class="p">;</span>           <span class="cm">/* 0 or 1 */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-get-irqchip">
<h2>4.26 KVM_GET_IRQCHIP<a class="headerlink" href="#kvm-get-irqchip" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IRQCHIP
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_irqchip (in/out)
Returns: 0 on success, -1 on error</p>
<p>Reads the state of a kernel interrupt controller created with
KVM_CREATE_IRQCHIP into a buffer provided by the caller.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">chip_id</span><span class="p">;</span>  <span class="cm">/* 0 = PIC1, 1 = PIC2, 2 = IOAPIC */</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>  <span class="cm">/* reserving space */</span>
                <span class="k">struct</span> <span class="n">kvm_pic_state</span> <span class="n">pic</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_ioapic_state</span> <span class="n">ioapic</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">chip</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-irqchip">
<h2>4.27 KVM_SET_IRQCHIP<a class="headerlink" href="#kvm-set-irqchip" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IRQCHIP
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_irqchip (in)
Returns: 0 on success, -1 on error</p>
<p>Sets the state of a kernel interrupt controller created with
KVM_CREATE_IRQCHIP from a buffer provided by the caller.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">chip_id</span><span class="p">;</span>  <span class="cm">/* 0 = PIC1, 1 = PIC2, 2 = IOAPIC */</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>  <span class="cm">/* reserving space */</span>
                <span class="k">struct</span> <span class="n">kvm_pic_state</span> <span class="n">pic</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_ioapic_state</span> <span class="n">ioapic</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">chip</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-xen-hvm-config">
<h2>4.28 KVM_XEN_HVM_CONFIG<a class="headerlink" href="#kvm-xen-hvm-config" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_XEN_HVM
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_xen_hvm_config (in)
Returns: 0 on success, -1 on error</p>
<p>Sets the MSR that the Xen HVM guest uses to initialize its hypercall
page, and provides the starting address and size of the hypercall
blobs in userspace.  When the guest writes the MSR, kvm copies one
page of a blob (32- or 64-bit, depending on the vcpu mode) to guest
memory.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_xen_hvm_config</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">msr</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">blob_addr_32</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">blob_addr_64</span><span class="p">;</span>
        <span class="n">__u8</span> <span class="n">blob_size_32</span><span class="p">;</span>
        <span class="n">__u8</span> <span class="n">blob_size_64</span><span class="p">;</span>
        <span class="n">__u8</span> <span class="n">pad2</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-get-clock">
<h2>4.29 KVM_GET_CLOCK<a class="headerlink" href="#kvm-get-clock" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_ADJUST_CLOCK
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_clock_data (out)
Returns: 0 on success, -1 on error</p>
<p>Gets the current timestamp of kvmclock as seen by the current guest. In
conjunction with KVM_SET_CLOCK, it is used to ensure monotonicity on scenarios
such as migration.</p>
<p>When KVM_CAP_ADJUST_CLOCK is passed to KVM_CHECK_EXTENSION, it returns the
set of bits that KVM can return in struct kvm_clock_data’s flag member.</p>
<p>The only flag defined now is KVM_CLOCK_TSC_STABLE.  If set, the returned
value is the exact kvmclock value seen by all VCPUs at the instant
when KVM_GET_CLOCK was called.  If clear, the returned value is simply
CLOCK_MONOTONIC plus a constant offset; the offset can be modified
with KVM_SET_CLOCK.  KVM will try to make all VCPUs follow this clock,
but the exact value read by each VCPU could differ, because the host
TSC is not stable.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_clock_data</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">clock</span><span class="p">;</span>  <span class="cm">/* kvmclock current value */</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-clock">
<h2>4.30 KVM_SET_CLOCK<a class="headerlink" href="#kvm-set-clock" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_ADJUST_CLOCK
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_clock_data (in)
Returns: 0 on success, -1 on error</p>
<p>Sets the current timestamp of kvmclock to the value specified in its parameter.
In conjunction with KVM_GET_CLOCK, it is used to ensure monotonicity on scenarios
such as migration.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_clock_data</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">clock</span><span class="p">;</span>  <span class="cm">/* kvmclock current value */</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-get-vcpu-events">
<h2>4.31 KVM_GET_VCPU_EVENTS<a class="headerlink" href="#kvm-get-vcpu-events" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_VCPU_EVENTS
Extended by: KVM_CAP_INTR_SHADOW
Architectures: x86, arm, arm64
Type: vcpu ioctl
Parameters: struct kvm_vcpu_event (out)
Returns: 0 on success, -1 on error</p>
<p>X86:</p>
<p>Gets currently pending exceptions, interrupts, and NMIs as well as related
states of the vcpu.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_vcpu_events</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="n">__u8</span> <span class="n">injected</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">nr</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">has_error_code</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">pending</span><span class="p">;</span>
                <span class="n">__u32</span> <span class="n">error_code</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">exception</span><span class="p">;</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="n">__u8</span> <span class="n">injected</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">nr</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">soft</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">shadow</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">interrupt</span><span class="p">;</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="n">__u8</span> <span class="n">injected</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">pending</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">masked</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">pad</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">nmi</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">sipi_vector</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="n">__u8</span> <span class="n">smm</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">pending</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">smm_inside_nmi</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">latched_init</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">smi</span><span class="p">;</span>
        <span class="n">__u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">27</span><span class="p">];</span>
        <span class="n">__u8</span> <span class="n">exception_has_payload</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">exception_payload</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The following bits are defined in the flags field:</p>
<ul class="simple">
<li><p>KVM_VCPUEVENT_VALID_SHADOW may be set to signal that
interrupt.shadow contains a valid state.</p></li>
<li><p>KVM_VCPUEVENT_VALID_SMM may be set to signal that smi contains a
valid state.</p></li>
<li><p>KVM_VCPUEVENT_VALID_PAYLOAD may be set to signal that the
exception_has_payload, exception_payload, and exception.pending
fields contain a valid state. This bit will be set whenever
KVM_CAP_EXCEPTION_PAYLOAD is enabled.</p></li>
</ul>
<p>ARM/ARM64:</p>
<p>If the guest accesses a device that is being emulated by the host kernel in
such a way that a real device would generate a physical SError, KVM may make
a virtual SError pending for that VCPU. This system error interrupt remains
pending until the guest takes the exception by unmasking PSTATE.A.</p>
<p>Running the VCPU may cause it to take a pending SError, or make an access that
causes an SError to become pending. The event’s description is only valid while
the VPCU is not running.</p>
<p>This API provides a way to read and write the pending ‘event’ state that is not
visible to the guest. To save, restore or migrate a VCPU the struct representing
the state can be read then written using this GET/SET API, along with the other
guest-visible registers. It is not possible to ‘cancel’ an SError that has been
made pending.</p>
<p>A device being emulated in user-space may also wish to generate an SError. To do
this the events structure can be populated by user-space. The current state
should be read first, to ensure no existing SError is pending. If an existing
SError is pending, the architecture’s ‘Multiple SError interrupts’ rules should
be followed. (2.5.3 of DDI0587.a “ARM Reliability, Availability, and
Serviceability (RAS) Specification”).</p>
<p>SError exceptions always have an ESR value. Some CPUs have the ability to
specify what the virtual SError’s ESR value should be. These systems will
advertise KVM_CAP_ARM_INJECT_SERROR_ESR. In this case exception.has_esr will
always have a non-zero value when read, and the agent making an SError pending
should specify the ISS field in the lower 24 bits of exception.serror_esr. If
the system supports KVM_CAP_ARM_INJECT_SERROR_ESR, but user-space sets the events
with exception.has_esr as zero, KVM will choose an ESR.</p>
<p>Specifying exception.has_esr on a system that does not support it will return
-EINVAL. Setting anything other than the lower 24bits of exception.serror_esr
will return -EINVAL.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_vcpu_events</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="n">__u8</span> <span class="n">serror_pending</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">serror_has_esr</span><span class="p">;</span>
                <span class="cm">/* Align it to 8 bytes */</span>
                <span class="n">__u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
                <span class="n">__u64</span> <span class="n">serror_esr</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">exception</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-vcpu-events">
<h2>4.32 KVM_SET_VCPU_EVENTS<a class="headerlink" href="#kvm-set-vcpu-events" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_VCPU_EVENTS
Extended by: KVM_CAP_INTR_SHADOW
Architectures: x86, arm, arm64
Type: vcpu ioctl
Parameters: struct kvm_vcpu_event (in)
Returns: 0 on success, -1 on error</p>
<p>X86:</p>
<p>Set pending exceptions, interrupts, and NMIs as well as related states of the
vcpu.</p>
<p>See KVM_GET_VCPU_EVENTS for the data structure.</p>
<p>Fields that may be modified asynchronously by running VCPUs can be excluded
from the update. These fields are nmi.pending, sipi_vector, smi.smm,
smi.pending. Keep the corresponding bits in the flags field cleared to
suppress overwriting the current in-kernel state. The bits are:</p>
<p>KVM_VCPUEVENT_VALID_NMI_PENDING - transfer nmi.pending to the kernel
KVM_VCPUEVENT_VALID_SIPI_VECTOR - transfer sipi_vector
KVM_VCPUEVENT_VALID_SMM         - transfer the smi sub-struct.</p>
<p>If KVM_CAP_INTR_SHADOW is available, KVM_VCPUEVENT_VALID_SHADOW can be set in
the flags field to signal that interrupt.shadow contains a valid state and
shall be written into the VCPU.</p>
<p>KVM_VCPUEVENT_VALID_SMM can only be set if KVM_CAP_X86_SMM is available.</p>
<p>If KVM_CAP_EXCEPTION_PAYLOAD is enabled, KVM_VCPUEVENT_VALID_PAYLOAD
can be set in the flags field to signal that the
exception_has_payload, exception_payload, and exception.pending fields
contain a valid state and shall be written into the VCPU.</p>
<p>ARM/ARM64:</p>
<p>Set the pending SError exception state for this VCPU. It is not possible to
‘cancel’ an Serror that has been made pending.</p>
<p>See KVM_GET_VCPU_EVENTS for the data structure.</p>
</div>
<div class="section" id="kvm-get-debugregs">
<h2>4.33 KVM_GET_DEBUGREGS<a class="headerlink" href="#kvm-get-debugregs" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_DEBUGREGS
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_debugregs (out)
Returns: 0 on success, -1 on error</p>
<p>Reads debug registers from the vcpu.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_debugregs</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">db</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
        <span class="n">__u64</span> <span class="n">dr6</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">dr7</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-debugregs">
<h2>4.34 KVM_SET_DEBUGREGS<a class="headerlink" href="#kvm-set-debugregs" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_DEBUGREGS
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_debugregs (in)
Returns: 0 on success, -1 on error</p>
<p>Writes debug registers into the vcpu.</p>
<p>See KVM_GET_DEBUGREGS for the data structure. The flags field is unused
yet and must be cleared on entry.</p>
</div>
<div class="section" id="kvm-set-user-memory-region">
<h2>4.35 KVM_SET_USER_MEMORY_REGION<a class="headerlink" href="#kvm-set-user-memory-region" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_USER_MEM
Architectures: all
Type: vm ioctl
Parameters: struct kvm_userspace_memory_region (in)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">slot</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">guest_phys_addr</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">memory_size</span><span class="p">;</span> <span class="cm">/* bytes */</span>
        <span class="n">__u64</span> <span class="n">userspace_addr</span><span class="p">;</span> <span class="cm">/* start of the userspace allocated memory */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>/* for kvm_memory_region::flags <a href="#id1"><span class="problematic" id="id2">*</span></a>/
#define KVM_MEM_LOG_DIRTY_PAGES (1UL &lt;&lt; 0)
#define KVM_MEM_READONLY        (1UL &lt;&lt; 1)</p>
<p>This ioctl allows the user to create, modify or delete a guest physical
memory slot.  Bits 0-15 of “slot” specify the slot id and this value
should be less than the maximum number of user memory slots supported per
VM.  The maximum allowed slots can be queried using KVM_CAP_NR_MEMSLOTS,
if this capability is supported by the architecture.  Slots may not
overlap in guest physical address space.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of “slot”
specifies the address space which is being modified.  They must be
less than the value that KVM_CHECK_EXTENSION returns for the
KVM_CAP_MULTI_ADDRESS_SPACE capability.  Slots in separate address spaces
are unrelated; the restriction on overlapping slots only applies within
each address space.</p>
<p>Deleting a slot is done by passing zero for memory_size.  When changing
an existing slot, it may be moved in the guest physical memory space,
or its flags may be modified, but it may not be resized.</p>
<p>Memory for the region is taken starting at the address denoted by the
field userspace_addr, which must point at user addressable memory for
the entire memory slot size.  Any object may back this memory, including
anonymous memory, ordinary files, and hugetlbfs.</p>
<p>It is recommended that the lower 21 bits of guest_phys_addr and userspace_addr
be identical.  This allows large pages in the guest to be backed by large
pages in the host.</p>
<p>The flags field supports two flags: KVM_MEM_LOG_DIRTY_PAGES and
KVM_MEM_READONLY.  The former can be set to instruct KVM to keep track of
writes to memory within the slot.  See KVM_GET_DIRTY_LOG ioctl to know how to
use it.  The latter can be set, if KVM_CAP_READONLY_MEM capability allows it,
to make a new slot read-only.  In this case, writes to this memory will be
posted to userspace as KVM_EXIT_MMIO exits.</p>
<p>When the KVM_CAP_SYNC_MMU capability is available, changes in the backing of
the memory region are automatically reflected into the guest.  For example, an
mmap() that affects the region will be made visible immediately.  Another
example is madvise(MADV_DROP).</p>
<p>It is recommended to use this API instead of the KVM_SET_MEMORY_REGION ioctl.
The KVM_SET_MEMORY_REGION does not allow fine grained control over memory
allocation and is deprecated.</p>
</div>
<div class="section" id="kvm-set-tss-addr">
<h2>4.36 KVM_SET_TSS_ADDR<a class="headerlink" href="#kvm-set-tss-addr" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SET_TSS_ADDR
Architectures: x86
Type: vm ioctl
Parameters: unsigned long tss_address (in)
Returns: 0 on success, -1 on error</p>
<p>This ioctl defines the physical address of a three-page region in the guest
physical address space.  The region must be within the first 4GB of the
guest physical address space and must not conflict with any memory slot
or any mmio address.  The guest may malfunction if it accesses this memory
region.</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware
because of a quirk in the virtualization implementation (see the internals
documentation when it pops into existence).</p>
</div>
<div class="section" id="kvm-enable-cap">
<h2>4.37 KVM_ENABLE_CAP<a class="headerlink" href="#kvm-enable-cap" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_ENABLE_CAP
Architectures: mips, ppc, s390
Type: vcpu ioctl
Parameters: struct kvm_enable_cap (in)
Returns: 0 on success; -1 on error</p>
<p>Capability: KVM_CAP_ENABLE_CAP_VM
Architectures: all
Type: vcpu ioctl
Parameters: struct kvm_enable_cap (in)
Returns: 0 on success; -1 on error</p>
<p>+Not all extensions are enabled by default. Using this ioctl the application
can enable an extension, making it available to the guest.</p>
<p>On systems that do not support this ioctl, it always fails. On systems that
do support it, it only works for extensions that are supported for enablement.</p>
<p>To check if a capability can be enabled, the KVM_CHECK_EXTENSION ioctl should
be used.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_enable_cap</span> <span class="p">{</span>
       <span class="cm">/* in */</span>
       <span class="n">__u32</span> <span class="n">cap</span><span class="p">;</span>
</pre></div>
</div>
<p>The capability that is supposed to get enabled.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
</pre></div>
</div>
<p>A bitfield indicating future enhancements. Has to be 0 for now.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__u64</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</pre></div>
</div>
<p>Arguments for enabling a feature. If a feature needs initial values to
function properly, this is the place to put them.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>       <span class="n">__u8</span>  <span class="n">pad</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The vcpu ioctl should be used for vcpu-specific capabilities, the vm ioctl
for vm-wide capabilities.</p>
</div>
<div class="section" id="kvm-get-mp-state">
<h2>4.38 KVM_GET_MP_STATE<a class="headerlink" href="#kvm-get-mp-state" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_MP_STATE
Architectures: x86, s390, arm, arm64
Type: vcpu ioctl
Parameters: struct kvm_mp_state (out)
Returns: 0 on success; -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">mp_state</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Returns the vcpu’s current “multiprocessing state” (though also valid on
uniprocessor guests).</p>
<p>Possible values are:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_MP_STATE_RUNNABLE:        the vcpu is currently running [x86,arm/arm64]</p></li>
<li><dl class="simple">
<dt>KVM_MP_STATE_UNINITIALIZED:   the vcpu is an application processor (AP)</dt><dd><p>which has not yet received an INIT signal [x86]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_MP_STATE_INIT_RECEIVED:   the vcpu has received an INIT signal, and is</dt><dd><p>now ready for a SIPI [x86]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_MP_STATE_HALTED:          the vcpu has executed a HLT instruction and</dt><dd><p>is waiting for an interrupt [x86]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_MP_STATE_SIPI_RECEIVED:   the vcpu has just received a SIPI (vector</dt><dd><p>accessible via KVM_GET_VCPU_EVENTS) [x86]</p>
</dd>
</dl>
</li>
<li><p>KVM_MP_STATE_STOPPED:         the vcpu is stopped [s390,arm/arm64]</p></li>
<li><p>KVM_MP_STATE_CHECK_STOP:      the vcpu is in a special error state [s390]</p></li>
<li><dl class="simple">
<dt>KVM_MP_STATE_OPERATING:       the vcpu is operating (running or halted)</dt><dd><p>[s390]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_MP_STATE_LOAD:            the vcpu is in a special load/startup state</dt><dd><p>[s390]</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an
in-kernel irqchip, the multiprocessing state must be maintained by userspace on
these architectures.</p>
<p>For arm/arm64:</p>
<p>The only states that are valid are KVM_MP_STATE_STOPPED and
KVM_MP_STATE_RUNNABLE which reflect if the vcpu is paused or not.</p>
</div>
<div class="section" id="kvm-set-mp-state">
<h2>4.39 KVM_SET_MP_STATE<a class="headerlink" href="#kvm-set-mp-state" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_MP_STATE
Architectures: x86, s390, arm, arm64
Type: vcpu ioctl
Parameters: struct kvm_mp_state (in)
Returns: 0 on success; -1 on error</p>
<p>Sets the vcpu’s current “multiprocessing state”; see KVM_GET_MP_STATE for
arguments.</p>
<p>On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an
in-kernel irqchip, the multiprocessing state must be maintained by userspace on
these architectures.</p>
<p>For arm/arm64:</p>
<p>The only states that are valid are KVM_MP_STATE_STOPPED and
KVM_MP_STATE_RUNNABLE which reflect if the vcpu should be paused or not.</p>
</div>
<div class="section" id="kvm-set-identity-map-addr">
<h2>4.40 KVM_SET_IDENTITY_MAP_ADDR<a class="headerlink" href="#kvm-set-identity-map-addr" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SET_IDENTITY_MAP_ADDR
Architectures: x86
Type: vm ioctl
Parameters: unsigned long identity (in)
Returns: 0 on success, -1 on error</p>
<p>This ioctl defines the physical address of a one-page region in the guest
physical address space.  The region must be within the first 4GB of the
guest physical address space and must not conflict with any memory slot
or any mmio address.  The guest may malfunction if it accesses this memory
region.</p>
<p>Setting the address to 0 will result in resetting the address to its default
(0xfffbc000).</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware
because of a quirk in the virtualization implementation (see the internals
documentation when it pops into existence).</p>
<p>Fails if any VCPU has already been created.</p>
</div>
<div class="section" id="kvm-set-boot-cpu-id">
<h2>4.41 KVM_SET_BOOT_CPU_ID<a class="headerlink" href="#kvm-set-boot-cpu-id" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SET_BOOT_CPU_ID
Architectures: x86
Type: vm ioctl
Parameters: unsigned long vcpu_id
Returns: 0 on success, -1 on error</p>
<p>Define which vcpu is the Bootstrap Processor (BSP).  Values are the same
as the vcpu id in KVM_CREATE_VCPU.  If this ioctl is not called, the default
is vcpu 0.</p>
</div>
<div class="section" id="kvm-get-xsave">
<h2>4.42 KVM_GET_XSAVE<a class="headerlink" href="#kvm-get-xsave" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_XSAVE
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_xsave (out)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_xsave</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">region</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl would copy current vcpu’s xsave struct to the userspace.</p>
</div>
<div class="section" id="kvm-set-xsave">
<h2>4.43 KVM_SET_XSAVE<a class="headerlink" href="#kvm-set-xsave" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_XSAVE
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_xsave (in)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_xsave</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">region</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl would copy userspace’s xsave struct to the kernel.</p>
</div>
<div class="section" id="kvm-get-xcrs">
<h2>4.44 KVM_GET_XCRS<a class="headerlink" href="#kvm-get-xcrs" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_XCRS
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_xcrs (out)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_xcr</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">xcr</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_xcrs</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nr_xcrs</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_xcr</span> <span class="n">xcrs</span><span class="p">[</span><span class="n">KVM_MAX_XCRS</span><span class="p">];</span>
        <span class="n">__u64</span> <span class="n">padding</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl would copy current vcpu’s xcrs to the userspace.</p>
</div>
<div class="section" id="kvm-set-xcrs">
<h2>4.45 KVM_SET_XCRS<a class="headerlink" href="#kvm-set-xcrs" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_XCRS
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_xcrs (in)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_xcr</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">xcr</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_xcrs</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nr_xcrs</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_xcr</span> <span class="n">xcrs</span><span class="p">[</span><span class="n">KVM_MAX_XCRS</span><span class="p">];</span>
        <span class="n">__u64</span> <span class="n">padding</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl would set vcpu’s xcr to the value userspace specified.</p>
</div>
<div class="section" id="kvm-get-supported-cpuid">
<h2>4.46 KVM_GET_SUPPORTED_CPUID<a class="headerlink" href="#kvm-get-supported-cpuid" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_EXT_CPUID
Architectures: x86
Type: system ioctl
Parameters: struct kvm_cpuid2 (in/out)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nent</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX      BIT(0)</span>
<span class="cp">#define KVM_CPUID_FLAG_STATEFUL_FUNC         BIT(1)</span>
<span class="cp">#define KVM_CPUID_FLAG_STATE_READ_NEXT       BIT(2)</span>

<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">function</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">index</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">eax</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ebx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ecx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">edx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl returns x86 cpuid features which are supported by both the
hardware and kvm in its default configuration.  Userspace can use the
information returned by this ioctl to construct cpuid information (for
KVM_SET_CPUID2) that is consistent with hardware, kernel, and
userspace capabilities, and with user requirements (for example, the
user may wish to constrain cpuid to emulate older hardware, or for
feature consistency across a cluster).</p>
<p>Note that certain capabilities, such as KVM_CAP_X86_DISABLE_EXITS, may
expose cpuid features (e.g. MONITOR) which are not supported by kvm in
its default configuration. If userspace enables such capabilities, it
is responsible for modifying the results of this ioctl appropriately.</p>
<p>Userspace invokes KVM_GET_SUPPORTED_CPUID by passing a kvm_cpuid2 structure
with the ‘nent’ field indicating the number of entries in the variable-size
array ‘entries’.  If the number of entries is too low to describe the cpu
capabilities, an error (E2BIG) is returned.  If the number is too high,
the ‘nent’ field is adjusted and an error (ENOMEM) is returned.  If the
number is just right, the ‘nent’ field is adjusted to the number of valid
entries in the ‘entries’ array, which is then filled.</p>
<p>The entries returned are the host cpuid as returned by the cpuid instruction,
with unknown or unsupported features masked out.  Some features (for example,
x2apic), may not be present in the host cpu, but are exposed by kvm if it can
emulate them efficiently. The fields in each entry are defined as follows:</p>
<blockquote>
<div><p>function: the eax value used to obtain the entry
index: the ecx value used to obtain the entry (for entries that are</p>
<blockquote>
<div><p>affected by ecx)</p>
</div></blockquote>
<dl>
<dt>flags: an OR of zero or more of the following:</dt><dd><blockquote>
<div><dl class="simple">
<dt>KVM_CPUID_FLAG_SIGNIFCANT_INDEX:</dt><dd><p>if the index field is valid</p>
</dd>
<dt>KVM_CPUID_FLAG_STATEFUL_FUNC:</dt><dd><p>if cpuid for this function returns different values for successive
invocations; there will be several entries with the same function,
all with this flag set</p>
</dd>
<dt>KVM_CPUID_FLAG_STATE_READ_NEXT:</dt><dd><p>for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is
the first entry to be read by a cpu</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>eax, ebx, ecx, edx: the values returned by the cpuid instruction for</dt><dd><p>this function/index combination</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>The TSC deadline timer feature (CPUID leaf 1, ecx[24]) is always returned
as false, since the feature depends on KVM_CREATE_IRQCHIP for local APIC
support.  Instead it is reported via</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_CHECK_EXTENSION</span><span class="p">,</span> <span class="n">KVM_CAP_TSC_DEADLINE_TIMER</span><span class="p">)</span>
</pre></div>
</div>
<p>if that returns true and you use KVM_CREATE_IRQCHIP, or if you emulate the
feature in userspace, then you can enable the feature for KVM_SET_CPUID2.</p>
</div>
<div class="section" id="kvm-ppc-get-pvinfo">
<h2>4.47 KVM_PPC_GET_PVINFO<a class="headerlink" href="#kvm-ppc-get-pvinfo" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_GET_PVINFO
Architectures: ppc
Type: vm ioctl
Parameters: struct kvm_ppc_pvinfo (out)
Returns: 0 on success, !0 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_pvinfo</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">hcall</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
        <span class="n">__u8</span>  <span class="n">pad</span><span class="p">[</span><span class="mi">108</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl fetches PV specific information that need to be passed to the guest
using the device tree or other means from vm context.</p>
<p>The hcall array defines 4 instructions that make up a hypercall.</p>
<p>If any additional field gets added to this structure later on, a bit for that
additional piece of information will be set in the flags bitmap.</p>
<p>The flags bitmap is defined as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* the host supports the ePAPR idle hcall</span>
<span class="cm">#define KVM_PPC_PVINFO_FLAGS_EV_IDLE   (1&lt;&lt;0)</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-gsi-routing">
<h2>4.52 KVM_SET_GSI_ROUTING<a class="headerlink" href="#kvm-set-gsi-routing" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IRQ_ROUTING
Architectures: x86 s390 arm arm64
Type: vm ioctl
Parameters: struct kvm_irq_routing (in)
Returns: 0 on success, -1 on error</p>
<p>Sets the GSI routing table entries, overwriting any previously set entries.</p>
<p>On arm/arm64, GSI routing has the following limitation:
- GSI routing does not apply to KVM_IRQ_LINE but only to KVM_IRQFD.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_irq_routing</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nr</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_irq_routing_entry</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>No flags are specified so far, the corresponding field must be set to zero.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_irq_routing_entry</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">gsi</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">kvm_irq_routing_irqchip</span> <span class="n">irqchip</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_irq_routing_msi</span> <span class="n">msi</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_irq_routing_s390_adapter</span> <span class="n">adapter</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_irq_routing_hv_sint</span> <span class="n">hv_sint</span><span class="p">;</span>
                <span class="n">__u32</span> <span class="n">pad</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
        <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* gsi routing entry types */</span>
<span class="cp">#define KVM_IRQ_ROUTING_IRQCHIP 1</span>
<span class="cp">#define KVM_IRQ_ROUTING_MSI 2</span>
<span class="cp">#define KVM_IRQ_ROUTING_S390_ADAPTER 3</span>
<span class="cp">#define KVM_IRQ_ROUTING_HV_SINT 4</span>
</pre></div>
</div>
<p>flags:
- KVM_MSI_VALID_DEVID: used along with KVM_IRQ_ROUTING_MSI routing entry</p>
<blockquote>
<div><p>type, specifies that the devid field contains a valid value.  The per-VM
KVM_CAP_MSI_DEVID capability advertises the requirement to provide
the device ID.  If this capability is not available, userspace should
never set the KVM_MSI_VALID_DEVID flag as the ioctl might fail.</p>
</div></blockquote>
<ul class="simple">
<li><p>zero otherwise</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_irq_routing_irqchip</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">irqchip</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pin</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_irq_routing_msi</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">address_lo</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">address_hi</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">data</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
                <span class="n">__u32</span> <span class="n">devid</span><span class="p">;</span>
        <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If KVM_MSI_VALID_DEVID is set, devid contains a unique device identifier
for the device that wrote the MSI message.  For PCI, this is usually a
BFD identifier in the lower 16 bits.</p>
<p>On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS
feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,
address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of
address_hi must be zero.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_irq_routing_s390_adapter</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">ind_addr</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">summary_addr</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">ind_offset</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">summary_offset</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">adapter_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_irq_routing_hv_sint</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">vcpu</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">sint</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-tsc-khz">
<h2>4.55 KVM_SET_TSC_KHZ<a class="headerlink" href="#kvm-set-tsc-khz" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_TSC_CONTROL
Architectures: x86
Type: vcpu ioctl
Parameters: virtual tsc_khz
Returns: 0 on success, -1 on error</p>
<p>Specifies the tsc frequency for the virtual machine. The unit of the
frequency is KHz.</p>
</div>
<div class="section" id="kvm-get-tsc-khz">
<h2>4.56 KVM_GET_TSC_KHZ<a class="headerlink" href="#kvm-get-tsc-khz" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_GET_TSC_KHZ
Architectures: x86
Type: vcpu ioctl
Parameters: none
Returns: virtual tsc-khz on success, negative value on error</p>
<p>Returns the tsc frequency of the guest. The unit of the return value is
KHz. If the host has unstable tsc this ioctl returns -EIO instead as an
error.</p>
</div>
<div class="section" id="kvm-get-lapic">
<h2>4.57 KVM_GET_LAPIC<a class="headerlink" href="#kvm-get-lapic" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IRQCHIP
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_lapic_state (out)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define KVM_APIC_REG_SIZE 0x400</span>
<span class="k">struct</span> <span class="n">kvm_lapic_state</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">regs</span><span class="p">[</span><span class="n">KVM_APIC_REG_SIZE</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Reads the Local APIC registers and copies them into the input argument.  The
data format and layout are the same as documented in the architecture manual.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature of KVM_CAP_X2APIC_API is
enabled, then the format of APIC_ID register depends on the APIC mode
(reported by MSR_IA32_APICBASE) of its VCPU.  x2APIC stores APIC ID in
the APIC_ID register (bytes 32-35).  xAPIC only allows an 8-bit APIC ID
which is stored in bits 31-24 of the APIC register, or equivalently in
byte 35 of struct kvm_lapic_state’s regs field.  KVM_GET_LAPIC must then
be called after MSR_IA32_APICBASE has been set with KVM_SET_MSR.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature is disabled, struct kvm_lapic_state
always uses xAPIC format.</p>
</div>
<div class="section" id="kvm-set-lapic">
<h2>4.58 KVM_SET_LAPIC<a class="headerlink" href="#kvm-set-lapic" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IRQCHIP
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_lapic_state (in)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define KVM_APIC_REG_SIZE 0x400</span>
<span class="k">struct</span> <span class="n">kvm_lapic_state</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">regs</span><span class="p">[</span><span class="n">KVM_APIC_REG_SIZE</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Copies the input argument into the Local APIC registers.  The data format
and layout are the same as documented in the architecture manual.</p>
<p>The format of the APIC ID register (bytes 32-35 of struct kvm_lapic_state’s
regs field) depends on the state of the KVM_CAP_X2APIC_API capability.
See the note in KVM_GET_LAPIC.</p>
</div>
<div class="section" id="kvm-ioeventfd">
<h2>4.59 KVM_IOEVENTFD<a class="headerlink" href="#kvm-ioeventfd" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IOEVENTFD
Architectures: all
Type: vm ioctl
Parameters: struct kvm_ioeventfd (in)
Returns: 0 on success, !0 on error</p>
<p>This ioctl attaches or detaches an ioeventfd to a legal pio/mmio address
within the guest.  A guest write in the registered address will signal the
provided event instead of triggering an exit.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ioeventfd</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">datamatch</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">addr</span><span class="p">;</span>        <span class="cm">/* legal pio/mmio address */</span>
        <span class="n">__u32</span> <span class="n">len</span><span class="p">;</span>         <span class="cm">/* 0, 1, 2, 4, or 8 bytes    */</span>
        <span class="n">__s32</span> <span class="n">fd</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">pad</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For the special case of virtio-ccw devices on s390, the ioevent is matched
to a subchannel/virtqueue tuple instead.</p>
<p>The following flags are defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define KVM_IOEVENTFD_FLAG_DATAMATCH (1 &lt;&lt; kvm_ioeventfd_flag_nr_datamatch)</span>
<span class="cp">#define KVM_IOEVENTFD_FLAG_PIO       (1 &lt;&lt; kvm_ioeventfd_flag_nr_pio)</span>
<span class="cp">#define KVM_IOEVENTFD_FLAG_DEASSIGN  (1 &lt;&lt; kvm_ioeventfd_flag_nr_deassign)</span>
<span class="cp">#define KVM_IOEVENTFD_FLAG_VIRTIO_CCW_NOTIFY \</span>
<span class="cp">        (1 &lt;&lt; kvm_ioeventfd_flag_nr_virtio_ccw_notify)</span>
</pre></div>
</div>
<p>If datamatch flag is set, the event will be signaled only if the written value
to the registered address is equal to datamatch in struct kvm_ioeventfd.</p>
<p>For virtio-ccw devices, addr contains the subchannel id and datamatch the
virtqueue index.</p>
<p>With KVM_CAP_IOEVENTFD_ANY_LENGTH, a zero length ioeventfd is allowed, and
the kernel will ignore the length of guest write and may get a faster vmexit.
The speedup may only apply to specific architectures, but the ioeventfd will
work anyway.</p>
</div>
<div class="section" id="kvm-dirty-tlb">
<h2>4.60 KVM_DIRTY_TLB<a class="headerlink" href="#kvm-dirty-tlb" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SW_TLB
Architectures: ppc
Type: vcpu ioctl
Parameters: struct kvm_dirty_tlb (in)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_dirty_tlb</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">bitmap</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">num_dirty</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This must be called whenever userspace has changed an entry in the shared
TLB, prior to calling KVM_RUN on the associated vcpu.</p>
<p>The “bitmap” field is the userspace address of an array.  This array
consists of a number of bits, equal to the total number of TLB entries as
determined by the last successful call to KVM_CONFIG_TLB, rounded up to the
nearest multiple of 64.</p>
<p>Each bit corresponds to one TLB entry, ordered the same as in the shared TLB
array.</p>
<p>The array is little-endian: the bit 0 is the least significant bit of the
first byte, bit 8 is the least significant bit of the second byte, etc.
This avoids any complications with differing word sizes.</p>
<p>The “num_dirty” field is a performance hint for KVM to determine whether it
should skip processing the bitmap and just invalidate everything.  It must
be set to the number of set bits in the bitmap.</p>
</div>
<div class="section" id="kvm-create-spapr-tce">
<h2>4.62 KVM_CREATE_SPAPR_TCE<a class="headerlink" href="#kvm-create-spapr-tce" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SPAPR_TCE
Architectures: powerpc
Type: vm ioctl
Parameters: struct kvm_create_spapr_tce (in)
Returns: file descriptor for manipulating the created TCE table</p>
<p>This creates a virtual TCE (translation control entry) table, which
is an IOMMU for PAPR-style virtual I/O.  It is used to translate
logical addresses used in virtual I/O into guest physical addresses,
and provides a scatter/gather capability for PAPR virtual I/O.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_CAP_SPAPR_TCE */</span>
<span class="k">struct</span> <span class="n">kvm_create_spapr_tce</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">liobn</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">window_size</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The liobn field gives the logical IO bus number for which to create a
TCE table.  The window_size field specifies the size of the DMA window
which this TCE table will translate - the table will contain one 64
bit TCE entry for every 4kiB of the DMA window.</p>
<p>When the guest issues an H_PUT_TCE hcall on a liobn for which a TCE
table has been created using this ioctl(), the kernel will handle it
in real mode, updating the TCE table.  H_PUT_TCE calls for other
liobns will cause a vm exit and must be handled by userspace.</p>
<p>The return value is a file descriptor which can be passed to mmap(2)
to map the created TCE table into userspace.  This lets userspace read
the entries written by kernel-handled H_PUT_TCE calls, and also lets
userspace update the TCE table directly which is useful in some
circumstances.</p>
</div>
<div class="section" id="kvm-allocate-rma">
<h2>4.63 KVM_ALLOCATE_RMA<a class="headerlink" href="#kvm-allocate-rma" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_RMA
Architectures: powerpc
Type: vm ioctl
Parameters: struct kvm_allocate_rma (out)
Returns: file descriptor for mapping the allocated RMA</p>
<p>This allocates a Real Mode Area (RMA) from the pool allocated at boot
time by the kernel.  An RMA is a physically-contiguous, aligned region
of memory used on older POWER processors to provide the memory which
will be accessed by real-mode (MMU off) accesses in a KVM guest.
POWER processors support a set of sizes for the RMA that usually
includes 64MB, 128MB, 256MB and some larger powers of two.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_ALLOCATE_RMA */</span>
<span class="k">struct</span> <span class="n">kvm_allocate_rma</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">rma_size</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The return value is a file descriptor which can be passed to mmap(2)
to map the allocated RMA into userspace.  The mapped area can then be
passed to the KVM_SET_USER_MEMORY_REGION ioctl to establish it as the
RMA for a virtual machine.  The size of the RMA in bytes (which is
fixed at host kernel boot time) is returned in the rma_size field of
the argument structure.</p>
<p>The KVM_CAP_PPC_RMA capability is 1 or 2 if the KVM_ALLOCATE_RMA ioctl
is supported; 2 if the processor requires all virtual machines to have
an RMA, or 1 if the processor can use an RMA but doesn’t require it,
because it supports the Virtual RMA (VRMA) facility.</p>
</div>
<div class="section" id="kvm-nmi">
<h2>4.64 KVM_NMI<a class="headerlink" href="#kvm-nmi" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_USER_NMI
Architectures: x86
Type: vcpu ioctl
Parameters: none
Returns: 0 on success, -1 on error</p>
<p>Queues an NMI on the thread’s vcpu.  Note this is well defined only
when KVM_CREATE_IRQCHIP has not been called, since this is an interface
between the virtual cpu core and virtual local APIC.  After KVM_CREATE_IRQCHIP
has been called, this interface is completely emulated within the kernel.</p>
<p>To use this to emulate the LINT1 input with KVM_CREATE_IRQCHIP, use the
following algorithm:</p>
<blockquote>
<div><ul class="simple">
<li><p>pause the vcpu</p></li>
<li><p>read the local APIC’s state (KVM_GET_LAPIC)</p></li>
<li><p>check whether changing LINT1 will queue an NMI (see the LVT entry for LINT1)</p></li>
<li><p>if so, issue KVM_NMI</p></li>
<li><p>resume the vcpu</p></li>
</ul>
</div></blockquote>
<p>Some guests configure the LINT1 NMI input to cause a panic, aiding in
debugging.</p>
</div>
<div class="section" id="kvm-s390-ucas-map">
<h2>4.65 KVM_S390_UCAS_MAP<a class="headerlink" href="#kvm-s390-ucas-map" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_UCONTROL
Architectures: s390
Type: vcpu ioctl
Parameters: struct kvm_s390_ucas_mapping (in)
Returns: 0 in case of success</p>
<p>The parameter is defined like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_ucas_mapping</span> <span class="p">{</span>
       <span class="n">__u64</span> <span class="n">user_addr</span><span class="p">;</span>
       <span class="n">__u64</span> <span class="n">vcpu_addr</span><span class="p">;</span>
       <span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl maps the memory at “user_addr” with the length “length” to
the vcpu’s address space starting at “vcpu_addr”. All parameters need to
be aligned by 1 megabyte.</p>
</div>
<div class="section" id="kvm-s390-ucas-unmap">
<h2>4.66 KVM_S390_UCAS_UNMAP<a class="headerlink" href="#kvm-s390-ucas-unmap" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_UCONTROL
Architectures: s390
Type: vcpu ioctl
Parameters: struct kvm_s390_ucas_mapping (in)
Returns: 0 in case of success</p>
<p>The parameter is defined like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_ucas_mapping</span> <span class="p">{</span>
    <span class="n">__u64</span> <span class="n">user_addr</span><span class="p">;</span>
    <span class="n">__u64</span> <span class="n">vcpu_addr</span><span class="p">;</span>
    <span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl unmaps the memory in the vcpu’s address space starting at
“vcpu_addr” with the length “length”. The field “user_addr” is ignored.
All parameters need to be aligned by 1 megabyte.</p>
</div>
<div class="section" id="kvm-s390-vcpu-fault">
<h2>4.67 KVM_S390_VCPU_FAULT<a class="headerlink" href="#kvm-s390-vcpu-fault" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_UCONTROL
Architectures: s390
Type: vcpu ioctl
Parameters: vcpu absolute address (in)
Returns: 0 in case of success</p>
<p>This call creates a page table entry on the virtual cpu’s address space
(for user controlled virtual machines) or the virtual machine’s address
space (for regular virtual machines). This only works for minor faults,
thus it’s recommended to access subject memory page via the user page
table upfront. This is useful to handle validity intercepts for user
controlled virtual machines to fault in the virtual cpu’s lowcore pages
prior to calling the KVM_RUN ioctl.</p>
</div>
<div class="section" id="kvm-set-one-reg">
<h2>4.68 KVM_SET_ONE_REG<a class="headerlink" href="#kvm-set-one-reg" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_ONE_REG
Architectures: all
Type: vcpu ioctl
Parameters: struct kvm_one_reg (in)
Returns: 0 on success, negative value on failure</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_one_reg</span> <span class="p">{</span>
       <span class="n">__u64</span> <span class="n">id</span><span class="p">;</span>
       <span class="n">__u64</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Using this ioctl, a single vcpu register can be set to a specific value
defined by user space with the passed in struct kvm_one_reg, where id
refers to the register identifier as described below and addr is a pointer
to a variable with the respective size. There can be architecture agnostic
and architecture specific registers. Each have their own range of operation
and their own constants and width. To keep track of the implemented
registers, find a list below:</p>
<blockquote>
<div><dl>
<dt>Arch  |           Register            | Width (bits)</dt><dd><div class="line-block">
<div class="line"><a href="#id3"><span class="problematic" id="id4">|</span></a></div>
</div>
</dd>
</dl>
<p>PPC   | KVM_REG_PPC_HIOR              | 64
PPC   | KVM_REG_PPC_IAC1              | 64
PPC   | KVM_REG_PPC_IAC2              | 64
PPC   | KVM_REG_PPC_IAC3              | 64
PPC   | KVM_REG_PPC_IAC4              | 64
PPC   | KVM_REG_PPC_DAC1              | 64
PPC   | KVM_REG_PPC_DAC2              | 64
PPC   | KVM_REG_PPC_DABR              | 64
PPC   | KVM_REG_PPC_DSCR              | 64
PPC   | KVM_REG_PPC_PURR              | 64
PPC   | KVM_REG_PPC_SPURR             | 64
PPC   | KVM_REG_PPC_DAR               | 64
PPC   | KVM_REG_PPC_DSISR             | 32
PPC   | KVM_REG_PPC_AMR               | 64
PPC   | KVM_REG_PPC_UAMOR             | 64
PPC   | KVM_REG_PPC_MMCR0             | 64
PPC   | KVM_REG_PPC_MMCR1             | 64
PPC   | KVM_REG_PPC_MMCRA             | 64
PPC   | KVM_REG_PPC_MMCR2             | 64
PPC   | KVM_REG_PPC_MMCRS             | 64
PPC   | KVM_REG_PPC_SIAR              | 64
PPC   | KVM_REG_PPC_SDAR              | 64
PPC   | KVM_REG_PPC_SIER              | 64
PPC   | KVM_REG_PPC_PMC1              | 32
PPC   | KVM_REG_PPC_PMC2              | 32
PPC   | KVM_REG_PPC_PMC3              | 32
PPC   | KVM_REG_PPC_PMC4              | 32
PPC   | KVM_REG_PPC_PMC5              | 32
PPC   | KVM_REG_PPC_PMC6              | 32
PPC   | KVM_REG_PPC_PMC7              | 32
PPC   | KVM_REG_PPC_PMC8              | 32
PPC   | KVM_REG_PPC_FPR0              | 64</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>PPC   | KVM_REG_PPC_FPR31             | 64
PPC   | KVM_REG_PPC_VR0               | 128</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>PPC   | KVM_REG_PPC_VR31              | 128
PPC   | KVM_REG_PPC_VSR0              | 128</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>PPC   | KVM_REG_PPC_VSR31             | 128
PPC   | KVM_REG_PPC_FPSCR             | 64
PPC   | KVM_REG_PPC_VSCR              | 32
PPC   | KVM_REG_PPC_VPA_ADDR          | 64
PPC   | KVM_REG_PPC_VPA_SLB           | 128
PPC   | KVM_REG_PPC_VPA_DTL           | 128
PPC   | KVM_REG_PPC_EPCR              | 32
PPC   | KVM_REG_PPC_EPR               | 32
PPC   | KVM_REG_PPC_TCR               | 32
PPC   | KVM_REG_PPC_TSR               | 32
PPC   | KVM_REG_PPC_OR_TSR            | 32
PPC   | KVM_REG_PPC_CLEAR_TSR         | 32
PPC   | KVM_REG_PPC_MAS0              | 32
PPC   | KVM_REG_PPC_MAS1              | 32
PPC   | KVM_REG_PPC_MAS2              | 64
PPC   | KVM_REG_PPC_MAS7_3            | 64
PPC   | KVM_REG_PPC_MAS4              | 32
PPC   | KVM_REG_PPC_MAS6              | 32
PPC   | KVM_REG_PPC_MMUCFG            | 32
PPC   | KVM_REG_PPC_TLB0CFG           | 32
PPC   | KVM_REG_PPC_TLB1CFG           | 32
PPC   | KVM_REG_PPC_TLB2CFG           | 32
PPC   | KVM_REG_PPC_TLB3CFG           | 32
PPC   | KVM_REG_PPC_TLB0PS            | 32
PPC   | KVM_REG_PPC_TLB1PS            | 32
PPC   | KVM_REG_PPC_TLB2PS            | 32
PPC   | KVM_REG_PPC_TLB3PS            | 32
PPC   | KVM_REG_PPC_EPTCFG            | 32
PPC   | KVM_REG_PPC_ICP_STATE         | 64
PPC   | KVM_REG_PPC_TB_OFFSET         | 64
PPC   | KVM_REG_PPC_SPMC1             | 32
PPC   | KVM_REG_PPC_SPMC2             | 32
PPC   | KVM_REG_PPC_IAMR              | 64
PPC   | KVM_REG_PPC_TFHAR             | 64
PPC   | KVM_REG_PPC_TFIAR             | 64
PPC   | KVM_REG_PPC_TEXASR            | 64
PPC   | KVM_REG_PPC_FSCR              | 64
PPC   | KVM_REG_PPC_PSPB              | 32
PPC   | KVM_REG_PPC_EBBHR             | 64
PPC   | KVM_REG_PPC_EBBRR             | 64
PPC   | KVM_REG_PPC_BESCR             | 64
PPC   | KVM_REG_PPC_TAR               | 64
PPC   | KVM_REG_PPC_DPDES             | 64
PPC   | KVM_REG_PPC_DAWR              | 64
PPC   | KVM_REG_PPC_DAWRX             | 64
PPC   | KVM_REG_PPC_CIABR             | 64
PPC   | KVM_REG_PPC_IC                | 64
PPC   | KVM_REG_PPC_VTB               | 64
PPC   | KVM_REG_PPC_CSIGR             | 64
PPC   | KVM_REG_PPC_TACR              | 64
PPC   | KVM_REG_PPC_TCSCR             | 64
PPC   | KVM_REG_PPC_PID               | 64
PPC   | KVM_REG_PPC_ACOP              | 64
PPC   | KVM_REG_PPC_VRSAVE            | 32
PPC   | KVM_REG_PPC_LPCR              | 32
PPC   | KVM_REG_PPC_LPCR_64           | 64
PPC   | KVM_REG_PPC_PPR               | 64
PPC   | KVM_REG_PPC_ARCH_COMPAT       | 32
PPC   | KVM_REG_PPC_DABRX             | 32
PPC   | KVM_REG_PPC_WORT              | 64
PPC   | KVM_REG_PPC_SPRG9             | 64
PPC   | KVM_REG_PPC_DBSR              | 32
PPC   | KVM_REG_PPC_TIDR              | 64
PPC   | KVM_REG_PPC_PSSCR             | 64
PPC   | KVM_REG_PPC_DEC_EXPIRY        | 64
PPC   | KVM_REG_PPC_PTCR              | 64
PPC   | KVM_REG_PPC_TM_GPR0           | 64</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>PPC   | KVM_REG_PPC_TM_GPR31          | 64
PPC   | KVM_REG_PPC_TM_VSR0           | 128</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>PPC   | KVM_REG_PPC_TM_VSR63          | 128
PPC   | KVM_REG_PPC_TM_CR             | 64
PPC   | KVM_REG_PPC_TM_LR             | 64
PPC   | KVM_REG_PPC_TM_CTR            | 64
PPC   | KVM_REG_PPC_TM_FPSCR          | 64
PPC   | KVM_REG_PPC_TM_AMR            | 64
PPC   | KVM_REG_PPC_TM_PPR            | 64
PPC   | KVM_REG_PPC_TM_VRSAVE         | 64
PPC   | KVM_REG_PPC_TM_VSCR           | 32
PPC   | KVM_REG_PPC_TM_DSCR           | 64
PPC   | KVM_REG_PPC_TM_TAR            | 64
PPC   | KVM_REG_PPC_TM_XER            | 64</p>
<blockquote>
<div><div class="line-block">
<div class="line"><a href="#id5"><span class="problematic" id="id6">|</span></a></div>
</div>
</div></blockquote>
<dl class="simple">
<dt>MIPS  | KVM_REG_MIPS_R0               | 64</dt><dd><p>…</p>
</dd>
</dl>
<p>MIPS  | KVM_REG_MIPS_R31              | 64
MIPS  | KVM_REG_MIPS_HI               | 64
MIPS  | KVM_REG_MIPS_LO               | 64
MIPS  | KVM_REG_MIPS_PC               | 64
MIPS  | KVM_REG_MIPS_CP0_INDEX        | 32
MIPS  | KVM_REG_MIPS_CP0_ENTRYLO0     | 64
MIPS  | KVM_REG_MIPS_CP0_ENTRYLO1     | 64
MIPS  | KVM_REG_MIPS_CP0_CONTEXT      | 64
MIPS  | KVM_REG_MIPS_CP0_CONTEXTCONFIG| 32
MIPS  | KVM_REG_MIPS_CP0_USERLOCAL    | 64
MIPS  | KVM_REG_MIPS_CP0_XCONTEXTCONFIG| 64
MIPS  | KVM_REG_MIPS_CP0_PAGEMASK     | 32
MIPS  | KVM_REG_MIPS_CP0_PAGEGRAIN    | 32
MIPS  | KVM_REG_MIPS_CP0_SEGCTL0      | 64
MIPS  | KVM_REG_MIPS_CP0_SEGCTL1      | 64
MIPS  | KVM_REG_MIPS_CP0_SEGCTL2      | 64
MIPS  | KVM_REG_MIPS_CP0_PWBASE       | 64
MIPS  | KVM_REG_MIPS_CP0_PWFIELD      | 64
MIPS  | KVM_REG_MIPS_CP0_PWSIZE       | 64
MIPS  | KVM_REG_MIPS_CP0_WIRED        | 32
MIPS  | KVM_REG_MIPS_CP0_PWCTL        | 32
MIPS  | KVM_REG_MIPS_CP0_HWRENA       | 32
MIPS  | KVM_REG_MIPS_CP0_BADVADDR     | 64
MIPS  | KVM_REG_MIPS_CP0_BADINSTR     | 32
MIPS  | KVM_REG_MIPS_CP0_BADINSTRP    | 32
MIPS  | KVM_REG_MIPS_CP0_COUNT        | 32
MIPS  | KVM_REG_MIPS_CP0_ENTRYHI      | 64
MIPS  | KVM_REG_MIPS_CP0_COMPARE      | 32
MIPS  | KVM_REG_MIPS_CP0_STATUS       | 32
MIPS  | KVM_REG_MIPS_CP0_INTCTL       | 32
MIPS  | KVM_REG_MIPS_CP0_CAUSE        | 32
MIPS  | KVM_REG_MIPS_CP0_EPC          | 64
MIPS  | KVM_REG_MIPS_CP0_PRID         | 32
MIPS  | KVM_REG_MIPS_CP0_EBASE        | 64
MIPS  | KVM_REG_MIPS_CP0_CONFIG       | 32
MIPS  | KVM_REG_MIPS_CP0_CONFIG1      | 32
MIPS  | KVM_REG_MIPS_CP0_CONFIG2      | 32
MIPS  | KVM_REG_MIPS_CP0_CONFIG3      | 32
MIPS  | KVM_REG_MIPS_CP0_CONFIG4      | 32
MIPS  | KVM_REG_MIPS_CP0_CONFIG5      | 32
MIPS  | KVM_REG_MIPS_CP0_CONFIG7      | 32
MIPS  | KVM_REG_MIPS_CP0_XCONTEXT     | 64
MIPS  | KVM_REG_MIPS_CP0_ERROREPC     | 64
MIPS  | KVM_REG_MIPS_CP0_KSCRATCH1    | 64
MIPS  | KVM_REG_MIPS_CP0_KSCRATCH2    | 64
MIPS  | KVM_REG_MIPS_CP0_KSCRATCH3    | 64
MIPS  | KVM_REG_MIPS_CP0_KSCRATCH4    | 64
MIPS  | KVM_REG_MIPS_CP0_KSCRATCH5    | 64
MIPS  | KVM_REG_MIPS_CP0_KSCRATCH6    | 64
MIPS  | KVM_REG_MIPS_CP0_MAAR(0..63)  | 64
MIPS  | KVM_REG_MIPS_COUNT_CTL        | 64
MIPS  | KVM_REG_MIPS_COUNT_RESUME     | 64
MIPS  | KVM_REG_MIPS_COUNT_HZ         | 64
MIPS  | KVM_REG_MIPS_FPR_32(0..31)    | 32
MIPS  | KVM_REG_MIPS_FPR_64(0..31)    | 64
MIPS  | KVM_REG_MIPS_VEC_128(0..31)   | 128
MIPS  | KVM_REG_MIPS_FCR_IR           | 32
MIPS  | KVM_REG_MIPS_FCR_CSR          | 32
MIPS  | KVM_REG_MIPS_MSA_IR           | 32
MIPS  | KVM_REG_MIPS_MSA_CSR          | 32</p>
</div></blockquote>
<p>ARM registers are mapped using the lower 32 bits.  The upper 16 of that
is the register group type, or coprocessor number:</p>
<dl class="simple">
<dt>ARM core registers have the following id bit patterns:</dt><dd><p>0x4020 0000 0010 &lt;index into the kvm_regs struct:16&gt;</p>
</dd>
<dt>ARM 32-bit CP15 registers have the following id bit patterns:</dt><dd><p>0x4020 0000 000F &lt;zero:1&gt; &lt;crn:4&gt; &lt;crm:4&gt; &lt;opc1:4&gt; &lt;opc2:3&gt;</p>
</dd>
<dt>ARM 64-bit CP15 registers have the following id bit patterns:</dt><dd><p>0x4030 0000 000F &lt;zero:1&gt; &lt;zero:4&gt; &lt;crm:4&gt; &lt;opc1:4&gt; &lt;zero:3&gt;</p>
</dd>
<dt>ARM CCSIDR registers are demultiplexed by CSSELR value:</dt><dd><p>0x4020 0000 0011 00 &lt;csselr:8&gt;</p>
</dd>
<dt>ARM 32-bit VFP control registers have the following id bit patterns:</dt><dd><p>0x4020 0000 0012 1 &lt;regno:12&gt;</p>
</dd>
<dt>ARM 64-bit FP registers have the following id bit patterns:</dt><dd><p>0x4030 0000 0012 0 &lt;regno:12&gt;</p>
</dd>
<dt>ARM firmware pseudo-registers have the following bit pattern:</dt><dd><p>0x4030 0000 0014 &lt;regno:16&gt;</p>
</dd>
</dl>
<p>arm64 registers are mapped using the lower 32 bits. The upper 16 of
that is the register group type, or coprocessor number:</p>
<p>arm64 core/FP-SIMD registers have the following id bit patterns. Note
that the size of the access is variable, as the kvm_regs structure
contains elements ranging from 32 to 128 bits. The index is a 32bit
value in the kvm_regs structure seen as a 32bit array.</p>
<blockquote>
<div><p>0x60x0 0000 0010 &lt;index into the kvm_regs struct:16&gt;</p>
</div></blockquote>
<dl class="simple">
<dt>arm64 CCSIDR registers are demultiplexed by CSSELR value:</dt><dd><p>0x6020 0000 0011 00 &lt;csselr:8&gt;</p>
</dd>
<dt>arm64 system registers have the following id bit patterns:</dt><dd><p>0x6030 0000 0013 &lt;op0:2&gt; &lt;op1:3&gt; &lt;crn:4&gt; &lt;crm:4&gt; &lt;op2:3&gt;</p>
</dd>
<dt>arm64 firmware pseudo-registers have the following bit pattern:</dt><dd><p>0x6030 0000 0014 &lt;regno:16&gt;</p>
</dd>
</dl>
<p>MIPS registers are mapped using the lower 32 bits.  The upper 16 of that is
the register group type:</p>
<dl class="simple">
<dt>MIPS core registers (see above) have the following id bit patterns:</dt><dd><p>0x7030 0000 0000 &lt;reg:16&gt;</p>
</dd>
</dl>
<p>MIPS CP0 registers (see KVM_REG_MIPS_CP0_* above) have the following id bit
patterns depending on whether they’re 32-bit or 64-bit registers:</p>
<blockquote>
<div><p>0x7020 0000 0001 00 &lt;reg:5&gt; &lt;sel:3&gt;   (32-bit)
0x7030 0000 0001 00 &lt;reg:5&gt; &lt;sel:3&gt;   (64-bit)</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>KVM_REG_MIPS_CP0_ENTRYLO0 and KVM_REG_MIPS_CP0_ENTRYLO1 are the MIPS64
versions of the EntryLo registers regardless of the word size of the host
hardware, host kernel, guest, and whether XPA is present in the guest, i.e.
with the RI and XI bits (if they exist) in bits 63 and 62 respectively, and
the PFNX field starting at bit 30.</p>
</div>
<p>MIPS MAARs (see KVM_REG_MIPS_CP0_MAAR(*) above) have the following id bit
patterns:</p>
<blockquote>
<div><p>0x7030 0000 0001 01 &lt;reg:8&gt;</p>
</div></blockquote>
<dl class="simple">
<dt>MIPS KVM control registers (see above) have the following id bit patterns:</dt><dd><p>0x7030 0000 0002 &lt;reg:16&gt;</p>
</dd>
</dl>
<p>MIPS FPU registers (see KVM_REG_MIPS_FPR_{32,64}() above) have the following
id bit patterns depending on the size of the register being accessed. They are
always accessed according to the current guest FPU mode (Status.FR and
Config5.FRE), i.e. as the guest would see them, and they become unpredictable
if the guest FPU mode is changed. MIPS SIMD Architecture (MSA) vector
registers (see KVM_REG_MIPS_VEC_128() above) have similar patterns as they
overlap the FPU registers:</p>
<blockquote>
<div><p>0x7020 0000 0003 00 &lt;0:3&gt; &lt;reg:5&gt; (32-bit FPU registers)
0x7030 0000 0003 00 &lt;0:3&gt; &lt;reg:5&gt; (64-bit FPU registers)
0x7040 0000 0003 00 &lt;0:3&gt; &lt;reg:5&gt; (128-bit MSA vector registers)</p>
</div></blockquote>
<p>MIPS FPU control registers (see KVM_REG_MIPS_FCR_{IR,CSR} above) have the
following id bit patterns:</p>
<blockquote>
<div><p>0x7020 0000 0003 01 &lt;0:3&gt; &lt;reg:5&gt;</p>
</div></blockquote>
<p>MIPS MSA control registers (see KVM_REG_MIPS_MSA_{IR,CSR} above) have the
following id bit patterns:</p>
<blockquote>
<div><p>0x7020 0000 0003 02 &lt;0:3&gt; &lt;reg:5&gt;</p>
</div></blockquote>
</div>
<div class="section" id="kvm-get-one-reg">
<h2>4.69 KVM_GET_ONE_REG<a class="headerlink" href="#kvm-get-one-reg" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_ONE_REG
Architectures: all
Type: vcpu ioctl
Parameters: struct kvm_one_reg (in and out)
Returns: 0 on success, negative value on failure</p>
<p>This ioctl allows to receive the value of a single register implemented
in a vcpu. The register to read is indicated by the “id” field of the
kvm_one_reg struct passed in. On success, the register value can be found
at the memory location pointed to by “addr”.</p>
<p>The list of registers accessible using this interface is identical to the
list in 4.68.</p>
</div>
<div class="section" id="kvm-kvmclock-ctrl">
<h2>4.70 KVM_KVMCLOCK_CTRL<a class="headerlink" href="#kvm-kvmclock-ctrl" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_KVMCLOCK_CTRL
Architectures: Any that implement pvclocks (currently x86 only)
Type: vcpu ioctl
Parameters: None
Returns: 0 on success, -1 on error</p>
<p>This signals to the host kernel that the specified guest is being paused by
userspace.  The host will set a flag in the pvclock structure that is checked
from the soft lockup watchdog.  The flag is part of the pvclock structure that
is shared between guest and host, specifically the second bit of the flags
field of the pvclock_vcpu_time_info structure.  It will be set exclusively by
the host and read/cleared exclusively by the guest.  The guest operation of
checking and clearing the flag must an atomic operation so
load-link/store-conditional, or equivalent must be used.  There are two cases
where the guest will clear the flag: when the soft lockup watchdog timer resets
itself or when a soft lockup is detected.  This ioctl can be called any time
after pausing the vcpu, but before it is resumed.</p>
</div>
<div class="section" id="kvm-signal-msi">
<h2>4.71 KVM_SIGNAL_MSI<a class="headerlink" href="#kvm-signal-msi" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SIGNAL_MSI
Architectures: x86 arm arm64
Type: vm ioctl
Parameters: struct kvm_msi (in)
Returns: &gt;0 on delivery, 0 if guest blocked the MSI, and -1 on error</p>
<p>Directly inject a MSI message. Only valid with in-kernel irqchip that handles
MSI messages.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_msi</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">address_lo</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">address_hi</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">devid</span><span class="p">;</span>
        <span class="n">__u8</span>  <span class="n">pad</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<dl class="simple">
<dt>flags: KVM_MSI_VALID_DEVID: devid contains a valid value.  The per-VM</dt><dd><p>KVM_CAP_MSI_DEVID capability advertises the requirement to provide
the device ID.  If this capability is not available, userspace
should never set the KVM_MSI_VALID_DEVID flag as the ioctl might fail.</p>
</dd>
</dl>
<p>If KVM_MSI_VALID_DEVID is set, devid contains a unique device identifier
for the device that wrote the MSI message.  For PCI, this is usually a
BFD identifier in the lower 16 bits.</p>
<p>On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS
feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,
address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of
address_hi must be zero.</p>
</div>
<div class="section" id="kvm-create-pit2">
<h2>4.71 KVM_CREATE_PIT2<a class="headerlink" href="#kvm-create-pit2" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PIT2
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_pit_config (in)
Returns: 0 on success, -1 on error</p>
<p>Creates an in-kernel device model for the i8254 PIT. This call is only valid
after enabling in-kernel irqchip support via KVM_CREATE_IRQCHIP. The following
parameters have to be passed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_pit_config</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Valid flags are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define KVM_PIT_SPEAKER_DUMMY     1 </span><span class="cm">/* emulate speaker port stub */</span><span class="cp"></span>
</pre></div>
</div>
<p>PIT timer interrupts may use a per-VM kernel thread for injection. If it
exists, this thread will have a name of the following pattern:</p>
<p>kvm-pit/&lt;owner-process-pid&gt;</p>
<p>When running a guest with elevated priorities, the scheduling parameters of
this thread may have to be adjusted accordingly.</p>
<p>This IOCTL replaces the obsolete KVM_CREATE_PIT.</p>
</div>
<div class="section" id="kvm-get-pit2">
<h2>4.72 KVM_GET_PIT2<a class="headerlink" href="#kvm-get-pit2" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PIT_STATE2
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_pit_state2 (out)
Returns: 0 on success, -1 on error</p>
<p>Retrieves the state of the in-kernel PIT model. Only valid after
KVM_CREATE_PIT2. The state is returned in the following structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_pit_state2</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kvm_pit_channel_state</span> <span class="n">channels</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Valid flags are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* disable PIT in HPET legacy mode */</span>
<span class="cp">#define KVM_PIT_FLAGS_HPET_LEGACY  0x00000001</span>
</pre></div>
</div>
<p>This IOCTL replaces the obsolete KVM_GET_PIT.</p>
</div>
<div class="section" id="kvm-set-pit2">
<h2>4.73 KVM_SET_PIT2<a class="headerlink" href="#kvm-set-pit2" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PIT_STATE2
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_pit_state2 (in)
Returns: 0 on success, -1 on error</p>
<p>Sets the state of the in-kernel PIT model. Only valid after KVM_CREATE_PIT2.
See KVM_GET_PIT2 for details on struct kvm_pit_state2.</p>
<p>This IOCTL replaces the obsolete KVM_SET_PIT.</p>
</div>
<div class="section" id="kvm-ppc-get-smmu-info">
<h2>4.74 KVM_PPC_GET_SMMU_INFO<a class="headerlink" href="#kvm-ppc-get-smmu-info" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_GET_SMMU_INFO
Architectures: powerpc
Type: vm ioctl
Parameters: None
Returns: 0 on success, -1 on error</p>
<p>This populates and returns a structure describing the features of
the “Server” class MMU emulation supported by KVM.
This can in turn be used by userspace to generate the appropriate
device-tree properties for the guest operating system.</p>
<p>The structure contains some global information, followed by an
array of supported segment page sizes:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_smmu_info</span> <span class="p">{</span>
       <span class="n">__u64</span> <span class="n">flags</span><span class="p">;</span>
       <span class="n">__u32</span> <span class="n">slb_size</span><span class="p">;</span>
       <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
       <span class="k">struct</span> <span class="n">kvm_ppc_one_seg_page_size</span> <span class="n">sps</span><span class="p">[</span><span class="n">KVM_PPC_PAGE_SIZES_MAX_SZ</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The supported flags are:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>KVM_PPC_PAGE_SIZES_REAL:</dt><dd><p>When that flag is set, guest page sizes must “fit” the backing
store page sizes. When not set, any page size in the list can
be used regardless of how they are backed by userspace.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_PPC_1T_SEGMENTS</dt><dd><p>The emulated MMU supports 1T segments in addition to the
standard 256M ones.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_PPC_NO_HASH</dt><dd><p>This flag indicates that HPT guests are not supported by KVM,
thus all guests must use radix MMU mode.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The “slb_size” field indicates how many SLB entries are supported</p>
<p>The “sps” array contains 8 entries indicating the supported base
page sizes for a segment in increasing order. Each entry is defined
as follow:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_one_seg_page_size</span> <span class="p">{</span>
     <span class="n">__u32</span> <span class="n">page_shift</span><span class="p">;</span>       <span class="cm">/* Base page shift of segment (or 0) */</span>
     <span class="n">__u32</span> <span class="n">slb_enc</span><span class="p">;</span>          <span class="cm">/* SLB encoding for BookS */</span>
     <span class="k">struct</span> <span class="n">kvm_ppc_one_page_size</span> <span class="n">enc</span><span class="p">[</span><span class="n">KVM_PPC_PAGE_SIZES_MAX_SZ</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>An entry with a “page_shift” of 0 is unused. Because the array is
organized in increasing order, a lookup can stop when encoutering
such an entry.</p>
<p>The “slb_enc” field provides the encoding to use in the SLB for the
page size. The bits are in positions such as the value can directly
be OR’ed into the “vsid” argument of the slbmte instruction.</p>
<p>The “enc” array is a list which for each of those segment base page
size provides the list of supported actual page sizes (which can be
only larger or equal to the base page size), along with the
corresponding encoding in the hash PTE. Similarly, the array is
8 entries sorted by increasing sizes and an entry with a “0” shift
is an empty entry and a terminator:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_one_page_size</span> <span class="p">{</span>
     <span class="n">__u32</span> <span class="n">page_shift</span><span class="p">;</span>       <span class="cm">/* Page shift (or 0) */</span>
     <span class="n">__u32</span> <span class="n">pte_enc</span><span class="p">;</span>          <span class="cm">/* Encoding in the HPTE (&gt;&gt;12) */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The “pte_enc” field provides a value that can OR’ed into the hash
PTE’s RPN field (ie, it needs to be shifted left by 12 to OR it
into the hash PTE second double word).</p>
</div>
<div class="section" id="kvm-irqfd">
<h2>4.75 KVM_IRQFD<a class="headerlink" href="#kvm-irqfd" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_IRQFD
Architectures: x86 s390 arm arm64
Type: vm ioctl
Parameters: struct kvm_irqfd (in)
Returns: 0 on success, -1 on error</p>
<p>Allows setting an eventfd to directly trigger a guest interrupt.
kvm_irqfd.fd specifies the file descriptor to use as the eventfd and
kvm_irqfd.gsi specifies the irqchip pin toggled by this event.  When
an event is triggered on the eventfd, an interrupt is injected into
the guest using the specified gsi pin.  The irqfd is removed using
the KVM_IRQFD_FLAG_DEASSIGN flag, specifying both kvm_irqfd.fd
and kvm_irqfd.gsi.</p>
<p>With KVM_CAP_IRQFD_RESAMPLE, KVM_IRQFD supports a de-assert and notify
mechanism allowing emulation of level-triggered, irqfd-based
interrupts.  When KVM_IRQFD_FLAG_RESAMPLE is set the user must pass an
additional eventfd in the kvm_irqfd.resamplefd field.  When operating
in resample mode, posting of an interrupt through kvm_irq.fd asserts
the specified gsi in the irqchip.  When the irqchip is resampled, such
as from an EOI, the gsi is de-asserted and the user is notified via
kvm_irqfd.resamplefd.  It is the user’s responsibility to re-queue
the interrupt if the device making use of it still requires service.
Note that closing the resamplefd is not sufficient to disable the
irqfd.  The KVM_IRQFD_FLAG_RESAMPLE is only necessary on assignment
and need not be specified with KVM_IRQFD_FLAG_DEASSIGN.</p>
<p>On arm/arm64, gsi routing being supported, the following can happen:
- in case no routing entry is associated to this gsi, injection fails
- in case the gsi is associated to an irqchip routing entry,</p>
<blockquote>
<div><p>irqchip.pin + 32 corresponds to the injected SPI ID.</p>
</div></blockquote>
<ul class="simple">
<li><p>in case the gsi is associated to an MSI routing entry, the MSI
message and device ID are translated into an LPI (support restricted
to GICv3 ITS in-kernel emulation).</p></li>
</ul>
</div>
<div class="section" id="kvm-ppc-allocate-htab">
<h2>4.76 KVM_PPC_ALLOCATE_HTAB<a class="headerlink" href="#kvm-ppc-allocate-htab" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_ALLOC_HTAB
Architectures: powerpc
Type: vm ioctl
Parameters: Pointer to u32 containing hash table order (in/out)
Returns: 0 on success, -1 on error</p>
<p>This requests the host kernel to allocate an MMU hash table for a
guest using the PAPR paravirtualization interface.  This only does
anything if the kernel is configured to use the Book 3S HV style of
virtualization.  Otherwise the capability doesn’t exist and the ioctl
returns an ENOTTY error.  The rest of this description assumes Book 3S
HV.</p>
<p>There must be no vcpus running when this ioctl is called; if there
are, it will do nothing and return an EBUSY error.</p>
<p>The parameter is a pointer to a 32-bit unsigned integer variable
containing the order (log base 2) of the desired size of the hash
table, which must be between 18 and 46.  On successful return from the
ioctl, the value will not be changed by the kernel.</p>
<p>If no hash table has been allocated when any vcpu is asked to run
(with the KVM_RUN ioctl), the host kernel will allocate a
default-sized hash table (16 MB).</p>
<p>If this ioctl is called when a hash table has already been allocated,
with a different order from the existing hash table, the existing hash
table will be freed and a new one allocated.  If this is ioctl is
called when a hash table has already been allocated of the same order
as specified, the kernel will clear out the existing hash table (zero
all HPTEs).  In either case, if the guest is using the virtualized
real-mode area (VRMA) facility, the kernel will re-create the VMRA
HPTEs on the next KVM_RUN of any vcpu.</p>
</div>
<div class="section" id="kvm-s390-interrupt">
<h2>4.77 KVM_S390_INTERRUPT<a class="headerlink" href="#kvm-s390-interrupt" title="Permalink to this headline">¶</a></h2>
<p>Capability: basic
Architectures: s390
Type: vm ioctl, vcpu ioctl
Parameters: struct kvm_s390_interrupt (in)
Returns: 0 on success, -1 on error</p>
<p>Allows to inject an interrupt to the guest. Interrupts can be floating
(vm ioctl) or per cpu (vcpu ioctl), depending on the interrupt type.</p>
<p>Interrupt parameters are passed via kvm_s390_interrupt:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_interrupt</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">parm</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">parm64</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>type can be one of the following:</p>
<p>KVM_S390_SIGP_STOP (vcpu) - sigp stop; optional flags in parm
KVM_S390_PROGRAM_INT (vcpu) - program check; code in parm
KVM_S390_SIGP_SET_PREFIX (vcpu) - sigp set prefix; prefix address in parm
KVM_S390_RESTART (vcpu) - restart
KVM_S390_INT_CLOCK_COMP (vcpu) - clock comparator interrupt
KVM_S390_INT_CPU_TIMER (vcpu) - CPU timer interrupt
KVM_S390_INT_VIRTIO (vm) - virtio external interrupt; external interrupt</p>
<blockquote>
<div><p>parameters in parm and parm64</p>
</div></blockquote>
<p>KVM_S390_INT_SERVICE (vm) - sclp external interrupt; sclp parameter in parm
KVM_S390_INT_EMERGENCY (vcpu) - sigp emergency; source cpu in parm
KVM_S390_INT_EXTERNAL_CALL (vcpu) - sigp external call; source cpu in parm
KVM_S390_INT_IO(ai,cssid,ssid,schid) (vm) - compound value to indicate an</p>
<blockquote>
<div><p>I/O interrupt (ai - adapter interrupt; cssid,ssid,schid - subchannel);
I/O interruption parameters in parm (subchannel) and parm64 (intparm,
interruption subclass)</p>
</div></blockquote>
<dl class="simple">
<dt>KVM_S390_MCHK (vm, vcpu) - machine check interrupt; cr 14 bits in parm,</dt><dd><p>machine check interrupt code in parm64 (note that
machine checks needing further payload are not
supported by this ioctl)</p>
</dd>
</dl>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</div>
<div class="section" id="kvm-ppc-get-htab-fd">
<h2>4.78 KVM_PPC_GET_HTAB_FD<a class="headerlink" href="#kvm-ppc-get-htab-fd" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_HTAB_FD
Architectures: powerpc
Type: vm ioctl
Parameters: Pointer to struct kvm_get_htab_fd (in)
Returns: file descriptor number (&gt;= 0) on success, -1 on error</p>
<p>This returns a file descriptor that can be used either to read out the
entries in the guest’s hashed page table (HPT), or to write entries to
initialize the HPT.  The returned fd can only be written to if the
KVM_GET_HTAB_WRITE bit is set in the flags field of the argument, and
can only be read if that bit is clear.  The argument struct looks like
this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* For KVM_PPC_GET_HTAB_FD */</span>
<span class="k">struct</span> <span class="n">kvm_get_htab_fd</span> <span class="p">{</span>
        <span class="n">__u64</span>        <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u64</span>        <span class="n">start_index</span><span class="p">;</span>
        <span class="n">__u64</span>        <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Values for kvm_get_htab_fd.flags */</span>
<span class="cp">#define KVM_GET_HTAB_BOLTED_ONLY     ((__u64)0x1)</span>
<span class="cp">#define KVM_GET_HTAB_WRITE           ((__u64)0x2)</span>
</pre></div>
</div>
<p>The <a href="#id7"><span class="problematic" id="id8">`</span></a>start_index’ field gives the index in the HPT of the entry at
which to start reading.  It is ignored when writing.</p>
<p>Reads on the fd will initially supply information about all
“interesting” HPT entries.  Interesting entries are those with the
bolted bit set, if the KVM_GET_HTAB_BOLTED_ONLY bit is set, otherwise
all entries.  When the end of the HPT is reached, the read() will
return.  If read() is called again on the fd, it will start again from
the beginning of the HPT, but will only return HPT entries that have
changed since they were last read.</p>
<p>Data read or written is structured as a header (8 bytes) followed by a
series of valid HPT entries (16 bytes) each.  The header indicates how
many valid HPT entries there are and how many invalid entries follow
the valid entries.  The invalid entries are not represented explicitly
in the stream.  The header format is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_get_htab_header</span> <span class="p">{</span>
        <span class="n">__u32</span>        <span class="n">index</span><span class="p">;</span>
        <span class="n">__u16</span>        <span class="n">n_valid</span><span class="p">;</span>
        <span class="n">__u16</span>        <span class="n">n_invalid</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Writes to the fd create HPT entries starting at the index given in the
header; first <a href="#id9"><span class="problematic" id="id10">`</span></a>n_valid’ valid entries with contents from the data
written, then <a href="#id11"><span class="problematic" id="id12">`</span></a>n_invalid’ invalid entries, invalidating any previously
valid entries found.</p>
</div>
<div class="section" id="kvm-create-device">
<h2>4.79 KVM_CREATE_DEVICE<a class="headerlink" href="#kvm-create-device" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_DEVICE_CTRL
Type: vm ioctl
Parameters: struct kvm_create_device (in/out)
Returns: 0 on success, -1 on error
Errors:</p>
<blockquote>
<div><p>ENODEV: The device type is unknown or unsupported
EEXIST: Device already created, and this type of device may not</p>
<blockquote>
<div><p>be instantiated multiple times</p>
</div></blockquote>
<p>Other error conditions may be defined by individual device types or
have their standard meanings.</p>
</div></blockquote>
<p>Creates an emulated device in the kernel.  The file descriptor returned
in fd can be used with KVM_SET/GET/HAS_DEVICE_ATTR.</p>
<p>If the KVM_CREATE_DEVICE_TEST flag is set, only test whether the
device type is supported (not necessarily whether it can be created
in the current vm).</p>
<p>Individual devices should not define flags.  Attributes should be used
for specifying any behavior that is not implied by the device type
number.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_create_device</span> <span class="p">{</span>
        <span class="n">__u32</span>        <span class="n">type</span><span class="p">;</span>   <span class="cm">/* in: KVM_DEV_TYPE_xxx */</span>
        <span class="n">__u32</span>        <span class="n">fd</span><span class="p">;</span>     <span class="cm">/* out: device handle */</span>
        <span class="n">__u32</span>        <span class="n">flags</span><span class="p">;</span>  <span class="cm">/* in: KVM_CREATE_DEVICE_xxx */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-set-device-attr-kvm-get-device-attr">
<h2>4.80 KVM_SET_DEVICE_ATTR/KVM_GET_DEVICE_ATTR<a class="headerlink" href="#kvm-set-device-attr-kvm-get-device-attr" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Capability: KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device,</dt><dd><p>KVM_CAP_VCPU_ATTRIBUTES for vcpu device</p>
</dd>
</dl>
<p>Type: device ioctl, vm ioctl, vcpu ioctl
Parameters: struct kvm_device_attr
Returns: 0 on success, -1 on error
Errors:</p>
<blockquote>
<div><dl class="simple">
<dt>ENXIO:  The group or attribute is unknown/unsupported for this device</dt><dd><p>or hardware support is missing.</p>
</dd>
<dt>EPERM:  The attribute cannot (currently) be accessed this way</dt><dd><p>(e.g. read-only attribute, or attribute that only makes
sense when the device is in a different state)</p>
</dd>
</dl>
<p>Other error conditions may be defined by individual device types.</p>
</div></blockquote>
<p>Gets/sets a specified piece of device configuration and/or state.  The
semantics are device-specific.  See individual device documentation in
the “devices” directory.  As with ONE_REG, the size of the data
transferred is defined by the particular attribute.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_device_attr</span> <span class="p">{</span>
        <span class="n">__u32</span>        <span class="n">flags</span><span class="p">;</span>          <span class="cm">/* no flags currently defined */</span>
        <span class="n">__u32</span>        <span class="n">group</span><span class="p">;</span>          <span class="cm">/* device-defined */</span>
        <span class="n">__u64</span>        <span class="n">attr</span><span class="p">;</span>           <span class="cm">/* group-defined */</span>
        <span class="n">__u64</span>        <span class="n">addr</span><span class="p">;</span>           <span class="cm">/* userspace address of attr data */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-has-device-attr">
<h2>4.81 KVM_HAS_DEVICE_ATTR<a class="headerlink" href="#kvm-has-device-attr" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Capability: KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device,</dt><dd><p>KVM_CAP_VCPU_ATTRIBUTES for vcpu device</p>
</dd>
</dl>
<p>Type: device ioctl, vm ioctl, vcpu ioctl
Parameters: struct kvm_device_attr
Returns: 0 on success, -1 on error
Errors:</p>
<blockquote>
<div><dl class="simple">
<dt>ENXIO:  The group or attribute is unknown/unsupported for this device</dt><dd><p>or hardware support is missing.</p>
</dd>
</dl>
</div></blockquote>
<p>Tests whether a device supports a particular attribute.  A successful
return indicates the attribute is implemented.  It does not necessarily
indicate that the attribute can be read or written in the device’s
current state.  “addr” is ignored.</p>
</div>
<div class="section" id="kvm-arm-vcpu-init">
<h2>4.82 KVM_ARM_VCPU_INIT<a class="headerlink" href="#kvm-arm-vcpu-init" title="Permalink to this headline">¶</a></h2>
<p>Capability: basic
Architectures: arm, arm64
Type: vcpu ioctl
Parameters: struct kvm_vcpu_init (in)
Returns: 0 on success; -1 on error
Errors:</p>
<blockquote>
<div><p>EINVAL:    the target is unknown, or the combination of features is invalid.
ENOENT:    a features bit specified is unknown.</p>
</div></blockquote>
<p>This tells KVM what type of CPU to present to the guest, and what
optional features it should have.  This will cause a reset of the cpu
registers to their initial values.  If this is not called, KVM_RUN will
return ENOEXEC for that vcpu.</p>
<p>Note that because some registers reflect machine topology, all vcpus
should be created before this ioctl is invoked.</p>
<p>Userspace can call this function multiple times for a given vcpu, including
after the vcpu has been run. This will reset the vcpu to its initial
state. All calls to this function after the initial call must use the same
target and same set of feature flags, otherwise EINVAL will be returned.</p>
<dl class="simple">
<dt>Possible features:</dt><dd><ul class="simple">
<li><p>KVM_ARM_VCPU_POWER_OFF: Starts the CPU in a power-off state.
Depends on KVM_CAP_ARM_PSCI.  If not set, the CPU will be powered on
and execute guest code when KVM_RUN is called.</p></li>
<li><p>KVM_ARM_VCPU_EL1_32BIT: Starts the CPU in a 32bit mode.
Depends on KVM_CAP_ARM_EL1_32BIT (arm64 only).</p></li>
<li><p>KVM_ARM_VCPU_PSCI_0_2: Emulate PSCI v0.2 (or a future revision
backward compatible with v0.2) for the CPU.
Depends on KVM_CAP_ARM_PSCI_0_2.</p></li>
<li><p>KVM_ARM_VCPU_PMU_V3: Emulate PMUv3 for the CPU.
Depends on KVM_CAP_ARM_PMU_V3.</p></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="kvm-arm-preferred-target">
<h2>4.83 KVM_ARM_PREFERRED_TARGET<a class="headerlink" href="#kvm-arm-preferred-target" title="Permalink to this headline">¶</a></h2>
<p>Capability: basic
Architectures: arm, arm64
Type: vm ioctl
Parameters: struct struct kvm_vcpu_init (out)
Returns: 0 on success; -1 on error
Errors:</p>
<blockquote>
<div><p>ENODEV:    no preferred target available for the host</p>
</div></blockquote>
<p>This queries KVM for preferred CPU target type which can be emulated
by KVM on underlying host.</p>
<p>The ioctl returns struct kvm_vcpu_init instance containing information
about preferred CPU target type and recommended features for it.  The
kvm_vcpu_init-&gt;features bitmap returned will have feature bits set if
the preferred target recommends setting these features, but this is
not mandatory.</p>
<p>The information returned by this ioctl can be used to prepare an instance
of struct kvm_vcpu_init for KVM_ARM_VCPU_INIT ioctl which will result in
in VCPU matching underlying host.</p>
</div>
<div class="section" id="kvm-get-reg-list">
<h2>4.84 KVM_GET_REG_LIST<a class="headerlink" href="#kvm-get-reg-list" title="Permalink to this headline">¶</a></h2>
<p>Capability: basic
Architectures: arm, arm64, mips
Type: vcpu ioctl
Parameters: struct kvm_reg_list (in/out)
Returns: 0 on success; -1 on error
Errors:</p>
<blockquote>
<div><p>E2BIG:     the reg index list is too big to fit in the array specified by
           the user (the number required will be written into n).</p>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_reg_list</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">n</span><span class="p">;</span> <span class="cm">/* number of registers in reg[] */</span>
        <span class="n">__u64</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl returns the guest registers that are supported for the
KVM_GET_ONE_REG/KVM_SET_ONE_REG calls.</p>
</div>
<div class="section" id="kvm-arm-set-device-addr-deprecated">
<h2>4.85 KVM_ARM_SET_DEVICE_ADDR (deprecated)<a class="headerlink" href="#kvm-arm-set-device-addr-deprecated" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_ARM_SET_DEVICE_ADDR
Architectures: arm, arm64
Type: vm ioctl
Parameters: struct kvm_arm_device_address (in)
Returns: 0 on success, -1 on error
Errors:</p>
<blockquote>
<div><p>ENODEV: The device id is unknown
ENXIO:  Device not supported on current system
EEXIST: Address already set
E2BIG:  Address outside guest physical address space
EBUSY:  Address overlaps with other device range</p>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_arm_device_addr</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">id</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Specify a device address in the guest’s physical address space where guests
can access emulated or directly exposed devices, which the host kernel needs
to know about. The id field is an architecture specific identifier for a
specific device.</p>
<p>ARM/arm64 divides the id field into two parts, a device id and an
address type id specific to the individual device.</p>
<blockquote>
<div><p>bits:  | 63        …       32 | 31    …    16 | 15    …    0 |
field: |        0x00000000      |     device id   |  addr type id  |</p>
</div></blockquote>
<p>ARM/arm64 currently only require this when using the in-kernel GIC
support for the hardware VGIC features, using KVM_ARM_DEVICE_VGIC_V2
as the device id.  When setting the base address for the guest’s
mapping of the VGIC virtual CPU and distributor interface, the ioctl
must be called after calling KVM_CREATE_IRQCHIP, but before calling
KVM_RUN on any of the VCPUs.  Calling this ioctl twice for any of the
base addresses will return -EEXIST.</p>
<p>Note, this IOCTL is deprecated and the more flexible SET/GET_DEVICE_ATTR API
should be used instead.</p>
</div>
<div class="section" id="kvm-ppc-rtas-define-token">
<h2>4.86 KVM_PPC_RTAS_DEFINE_TOKEN<a class="headerlink" href="#kvm-ppc-rtas-define-token" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_RTAS
Architectures: ppc
Type: vm ioctl
Parameters: struct kvm_rtas_token_args
Returns: 0 on success, -1 on error</p>
<p>Defines a token value for a RTAS (Run Time Abstraction Services)
service in order to allow it to be handled in the kernel.  The
argument struct gives the name of the service, which must be the name
of a service that has a kernel-side implementation.  If the token
value is non-zero, it will be associated with that service, and
subsequent RTAS calls by the guest specifying that token will be
handled by the kernel.  If the token value is 0, then any token
associated with the service will be forgotten, and subsequent RTAS
calls by the guest for that service will be passed to userspace to be
handled.</p>
</div>
<div class="section" id="kvm-set-guest-debug">
<h2>4.87 KVM_SET_GUEST_DEBUG<a class="headerlink" href="#kvm-set-guest-debug" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SET_GUEST_DEBUG
Architectures: x86, s390, ppc, arm64
Type: vcpu ioctl
Parameters: struct kvm_guest_debug (in)
Returns: 0 on success; -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_guest_debug</span> <span class="p">{</span>
       <span class="n">__u32</span> <span class="n">control</span><span class="p">;</span>
       <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
       <span class="k">struct</span> <span class="n">kvm_guest_debug_arch</span> <span class="n">arch</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Set up the processor specific debug registers and configure vcpu for
handling guest debug events. There are two parts to the structure, the
first a control bitfield indicates the type of debug events to handle
when running. Common control bits are:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_GUESTDBG_ENABLE:        guest debugging is enabled</p></li>
<li><p>KVM_GUESTDBG_SINGLESTEP:    the next run should single-step</p></li>
</ul>
</div></blockquote>
<p>The top 16 bits of the control field are architecture specific control
flags which can include the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_GUESTDBG_USE_SW_BP:     using software breakpoints [x86, arm64]</p></li>
<li><p>KVM_GUESTDBG_USE_HW_BP:     using hardware breakpoints [x86, s390, arm64]</p></li>
<li><p>KVM_GUESTDBG_INJECT_DB:     inject DB type exception [x86]</p></li>
<li><p>KVM_GUESTDBG_INJECT_BP:     inject BP type exception [x86]</p></li>
<li><p>KVM_GUESTDBG_EXIT_PENDING:  trigger an immediate guest exit [s390]</p></li>
</ul>
</div></blockquote>
<p>For example KVM_GUESTDBG_USE_SW_BP indicates that software breakpoints
are enabled in memory so we need to ensure breakpoint exceptions are
correctly trapped and the KVM run loop exits at the breakpoint and not
running off into the normal guest vector. For KVM_GUESTDBG_USE_HW_BP
we need to ensure the guest vCPUs architecture specific registers are
updated to the correct (supplied) values.</p>
<p>The second part of the structure is architecture specific and
typically contains a set of debug registers.</p>
<p>For arm64 the number of debug registers is implementation defined and
can be determined by querying the KVM_CAP_GUEST_DEBUG_HW_BPS and
KVM_CAP_GUEST_DEBUG_HW_WPS capabilities which return a positive number
indicating the number of supported registers.</p>
<p>When debug events exit the main run loop with the reason
KVM_EXIT_DEBUG with the kvm_debug_exit_arch part of the kvm_run
structure containing architecture specific debug information.</p>
</div>
<div class="section" id="kvm-get-emulated-cpuid">
<h2>4.88 KVM_GET_EMULATED_CPUID<a class="headerlink" href="#kvm-get-emulated-cpuid" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_EXT_EMUL_CPUID
Architectures: x86
Type: system ioctl
Parameters: struct kvm_cpuid2 (in/out)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nent</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The member ‘flags’ is used for passing flags from userspace.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX      BIT(0)</span>
<span class="cp">#define KVM_CPUID_FLAG_STATEFUL_FUNC         BIT(1)</span>
<span class="cp">#define KVM_CPUID_FLAG_STATE_READ_NEXT       BIT(2)</span>

<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">function</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">index</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">eax</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ebx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ecx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">edx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl returns x86 cpuid features which are emulated by
kvm.Userspace can use the information returned by this ioctl to query
which features are emulated by kvm instead of being present natively.</p>
<p>Userspace invokes KVM_GET_EMULATED_CPUID by passing a kvm_cpuid2
structure with the ‘nent’ field indicating the number of entries in
the variable-size array ‘entries’. If the number of entries is too low
to describe the cpu capabilities, an error (E2BIG) is returned. If the
number is too high, the ‘nent’ field is adjusted and an error (ENOMEM)
is returned. If the number is just right, the ‘nent’ field is adjusted
to the number of valid entries in the ‘entries’ array, which is then
filled.</p>
<p>The entries returned are the set CPUID bits of the respective features
which kvm emulates, as returned by the CPUID instruction, with unknown
or unsupported feature bits cleared.</p>
<p>Features like x2apic, for example, may not be present in the host cpu
but are exposed by kvm in KVM_GET_SUPPORTED_CPUID because they can be
emulated efficiently and thus not included here.</p>
<p>The fields in each entry are defined as follows:</p>
<blockquote>
<div><p>function: the eax value used to obtain the entry
index: the ecx value used to obtain the entry (for entries that are</p>
<blockquote>
<div><p>affected by ecx)</p>
</div></blockquote>
<dl>
<dt>flags: an OR of zero or more of the following:</dt><dd><blockquote>
<div><dl class="simple">
<dt>KVM_CPUID_FLAG_SIGNIFCANT_INDEX:</dt><dd><p>if the index field is valid</p>
</dd>
<dt>KVM_CPUID_FLAG_STATEFUL_FUNC:</dt><dd><p>if cpuid for this function returns different values for successive
invocations; there will be several entries with the same function,
all with this flag set</p>
</dd>
<dt>KVM_CPUID_FLAG_STATE_READ_NEXT:</dt><dd><p>for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is
the first entry to be read by a cpu</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>eax, ebx, ecx, edx: the values returned by the cpuid instruction for</dt><dd><p>this function/index combination</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="kvm-s390-mem-op">
<h2>4.89 KVM_S390_MEM_OP<a class="headerlink" href="#kvm-s390-mem-op" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_MEM_OP
Architectures: s390
Type: vcpu ioctl
Parameters: struct kvm_s390_mem_op (in)
Returns: = 0 on success,</p>
<blockquote>
<div><p>&lt; 0 on generic error (e.g. -EFAULT or -ENOMEM),
&gt; 0 if an exception occurred while walking the page tables</p>
</div></blockquote>
<p>Read or write data from/to the logical (virtual) memory of a VCPU.</p>
<p>Parameters are specified via the following structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_mem_op</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">gaddr</span><span class="p">;</span>         <span class="cm">/* the guest address */</span>
        <span class="n">__u64</span> <span class="n">flags</span><span class="p">;</span>         <span class="cm">/* flags */</span>
        <span class="n">__u32</span> <span class="n">size</span><span class="p">;</span>          <span class="cm">/* amount of bytes */</span>
        <span class="n">__u32</span> <span class="n">op</span><span class="p">;</span>            <span class="cm">/* type of operation */</span>
        <span class="n">__u64</span> <span class="n">buf</span><span class="p">;</span>           <span class="cm">/* buffer in userspace */</span>
        <span class="n">__u8</span> <span class="n">ar</span><span class="p">;</span>             <span class="cm">/* the access register number */</span>
        <span class="n">__u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>   <span class="cm">/* should be set to 0 */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The type of operation is specified in the “op” field. It is either
KVM_S390_MEMOP_LOGICAL_READ for reading from logical memory space or
KVM_S390_MEMOP_LOGICAL_WRITE for writing to logical memory space. The
KVM_S390_MEMOP_F_CHECK_ONLY flag can be set in the “flags” field to check
whether the corresponding memory access would create an access exception
(without touching the data in the memory at the destination). In case an
access exception occurred while walking the MMU tables of the guest, the
ioctl returns a positive error number to indicate the type of exception.
This exception is also raised directly at the corresponding VCPU if the
flag KVM_S390_MEMOP_F_INJECT_EXCEPTION is set in the “flags” field.</p>
<p>The start address of the memory region has to be specified in the “gaddr”
field, and the length of the region in the “size” field. “buf” is the buffer
supplied by the userspace application where the read data should be written
to for KVM_S390_MEMOP_LOGICAL_READ, or where the data that should be written
is stored for a KVM_S390_MEMOP_LOGICAL_WRITE. “buf” is unused and can be NULL
when KVM_S390_MEMOP_F_CHECK_ONLY is specified. “ar” designates the access
register number to be used.</p>
<p>The “reserved” field is meant for future extensions. It is not used by
KVM with the currently defined set of flags.</p>
</div>
<div class="section" id="kvm-s390-get-skeys">
<h2>4.90 KVM_S390_GET_SKEYS<a class="headerlink" href="#kvm-s390-get-skeys" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_SKEYS
Architectures: s390
Type: vm ioctl
Parameters: struct kvm_s390_skeys
Returns: 0 on success, KVM_S390_GET_KEYS_NONE if guest is not using storage</p>
<blockquote>
<div><p>keys, negative value on error</p>
</div></blockquote>
<p>This ioctl is used to get guest storage key values on the s390
architecture. The ioctl takes parameters via the kvm_s390_skeys struct.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_skeys</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">start_gfn</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">count</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">skeydata_addr</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The start_gfn field is the number of the first guest frame whose storage keys
you want to get.</p>
<p>The count field is the number of consecutive frames (starting from start_gfn)
whose storage keys to get. The count field must be at least 1 and the maximum
allowed value is defined as KVM_S390_SKEYS_ALLOC_MAX. Values outside this range
will cause the ioctl to return -EINVAL.</p>
<p>The skeydata_addr field is the address to a buffer large enough to hold count
bytes. This buffer will be filled with storage key data by the ioctl.</p>
</div>
<div class="section" id="kvm-s390-set-skeys">
<h2>4.91 KVM_S390_SET_SKEYS<a class="headerlink" href="#kvm-s390-set-skeys" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_SKEYS
Architectures: s390
Type: vm ioctl
Parameters: struct kvm_s390_skeys
Returns: 0 on success, negative value on error</p>
<p>This ioctl is used to set guest storage key values on the s390
architecture. The ioctl takes parameters via the kvm_s390_skeys struct.
See section on KVM_S390_GET_SKEYS for struct definition.</p>
<p>The start_gfn field is the number of the first guest frame whose storage keys
you want to set.</p>
<p>The count field is the number of consecutive frames (starting from start_gfn)
whose storage keys to get. The count field must be at least 1 and the maximum
allowed value is defined as KVM_S390_SKEYS_ALLOC_MAX. Values outside this range
will cause the ioctl to return -EINVAL.</p>
<p>The skeydata_addr field is the address to a buffer containing count bytes of
storage keys. Each byte in the buffer will be set as the storage key for a
single frame starting at start_gfn for count frames.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If any architecturally invalid key value is found in the given data then
the ioctl will return -EINVAL.</p>
</div>
</div>
<div class="section" id="kvm-s390-irq">
<h2>4.92 KVM_S390_IRQ<a class="headerlink" href="#kvm-s390-irq" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_INJECT_IRQ
Architectures: s390
Type: vcpu ioctl
Parameters: struct kvm_s390_irq (in)
Returns: 0 on success, -1 on error
Errors:</p>
<blockquote>
<div><dl>
<dt>EINVAL: interrupt type is invalid</dt><dd><p>type is KVM_S390_SIGP_STOP and flag parameter is invalid value
type is KVM_S390_INT_EXTERNAL_CALL and code is bigger</p>
<blockquote>
<div><p>than the maximum of VCPUs</p>
</div></blockquote>
</dd>
<dt>EBUSY:  type is KVM_S390_SIGP_SET_PREFIX and vcpu is not stopped</dt><dd><p>type is KVM_S390_SIGP_STOP and a stop irq is already pending
type is KVM_S390_INT_EXTERNAL_CALL and an external call interrupt</p>
<blockquote>
<div><p>is already pending</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>Allows to inject an interrupt to the guest.</p>
<p>Using struct kvm_s390_irq as a parameter allows
to inject additional payload which is not
possible via KVM_S390_INTERRUPT.</p>
<p>Interrupt parameters are passed via kvm_s390_irq:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_irq</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">type</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">kvm_s390_io_info</span> <span class="n">io</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_s390_ext_info</span> <span class="n">ext</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_s390_pgm_info</span> <span class="n">pgm</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_s390_emerg_info</span> <span class="n">emerg</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_s390_extcall_info</span> <span class="n">extcall</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_s390_prefix_info</span> <span class="n">prefix</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_s390_stop_info</span> <span class="n">stop</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_s390_mchk_info</span> <span class="n">mchk</span><span class="p">;</span>
                <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
        <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>type can be one of the following:</p>
<p>KVM_S390_SIGP_STOP - sigp stop; parameter in .stop
KVM_S390_PROGRAM_INT - program check; parameters in .pgm
KVM_S390_SIGP_SET_PREFIX - sigp set prefix; parameters in .prefix
KVM_S390_RESTART - restart; no parameters
KVM_S390_INT_CLOCK_COMP - clock comparator interrupt; no parameters
KVM_S390_INT_CPU_TIMER - CPU timer interrupt; no parameters
KVM_S390_INT_EMERGENCY - sigp emergency; parameters in .emerg
KVM_S390_INT_EXTERNAL_CALL - sigp external call; parameters in .extcall
KVM_S390_MCHK - machine check interrupt; parameters in .mchk</p>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</div>
<div class="section" id="kvm-s390-get-irq-state">
<h2>4.94 KVM_S390_GET_IRQ_STATE<a class="headerlink" href="#kvm-s390-get-irq-state" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_IRQ_STATE
Architectures: s390
Type: vcpu ioctl
Parameters: struct kvm_s390_irq_state (out)
Returns: &gt;= number of bytes copied into buffer,</p>
<blockquote>
<div><p>-EINVAL if buffer size is 0,
-ENOBUFS if buffer size is too small to fit all pending interrupts,
-EFAULT if the buffer address was invalid</p>
</div></blockquote>
<p>This ioctl allows userspace to retrieve the complete state of all currently
pending interrupts in a single buffer. Use cases include migration
and introspection. The parameter structure contains the address of a
userspace buffer and its length:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_irq_state</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>        <span class="cm">/* will stay unused for compatibility reasons */</span>
        <span class="n">__u32</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>  <span class="cm">/* will stay unused for compatibility reasons */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Userspace passes in the above struct and for each pending interrupt a
struct kvm_s390_irq is copied to the provided buffer.</p>
<p>The structure contains a flags and a reserved field for future extensions. As
the kernel never checked for flags == 0 and QEMU never pre-zeroed flags and
reserved, these fields can not be used in the future without breaking
compatibility.</p>
<p>If -ENOBUFS is returned the buffer provided was too small and userspace
may retry with a bigger buffer.</p>
</div>
<div class="section" id="kvm-s390-set-irq-state">
<h2>4.95 KVM_S390_SET_IRQ_STATE<a class="headerlink" href="#kvm-s390-set-irq-state" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_IRQ_STATE
Architectures: s390
Type: vcpu ioctl
Parameters: struct kvm_s390_irq_state (in)
Returns: 0 on success,</p>
<blockquote>
<div><p>-EFAULT if the buffer address was invalid,
-EINVAL for an invalid buffer length (see below),
-EBUSY if there were already interrupts pending,
errors occurring when actually injecting the</p>
<blockquote>
<div><p>interrupt. See KVM_S390_IRQ.</p>
</div></blockquote>
</div></blockquote>
<p>This ioctl allows userspace to set the complete state of all cpu-local
interrupts currently pending for the vcpu. It is intended for restoring
interrupt state after a migration. The input parameter is a userspace buffer
containing a struct kvm_s390_irq_state:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_irq_state</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>        <span class="cm">/* will stay unused for compatibility reasons */</span>
        <span class="n">__u32</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>  <span class="cm">/* will stay unused for compatibility reasons */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The restrictions for flags and reserved apply as well.
(see KVM_S390_GET_IRQ_STATE)</p>
<p>The userspace memory referenced by buf contains a struct kvm_s390_irq
for each interrupt to be injected into the guest.
If one of the interrupts could not be injected for some reason the
ioctl aborts.</p>
<p>len must be a multiple of sizeof(struct kvm_s390_irq). It must be &gt; 0
and it must not exceed (max_vcpus + 32) * sizeof(struct kvm_s390_irq),
which is the maximum number of possibly pending cpu-local interrupts.</p>
</div>
<div class="section" id="kvm-smi">
<h2>4.96 KVM_SMI<a class="headerlink" href="#kvm-smi" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_X86_SMM
Architectures: x86
Type: vcpu ioctl
Parameters: none
Returns: 0 on success, -1 on error</p>
<p>Queues an SMI on the thread’s vcpu.</p>
</div>
<div class="section" id="kvm-cap-ppc-multitce">
<h2>4.97 KVM_CAP_PPC_MULTITCE<a class="headerlink" href="#kvm-cap-ppc-multitce" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_MULTITCE
Architectures: ppc
Type: vm</p>
<p>This capability means the kernel is capable of handling hypercalls
H_PUT_TCE_INDIRECT and H_STUFF_TCE without passing those into the user
space. This significantly accelerates DMA operations for PPC KVM guests.
User space should expect that its handlers for these hypercalls
are not going to be called if user space previously registered LIOBN
in KVM (via KVM_CREATE_SPAPR_TCE or similar calls).</p>
<p>In order to enable H_PUT_TCE_INDIRECT and H_STUFF_TCE use in the guest,
user space might have to advertise it for the guest. For example,
IBM pSeries (sPAPR) guest starts using them if “hcall-multi-tce” is
present in the “ibm,hypertas-functions” device-tree property.</p>
<p>The hypercalls mentioned above may or may not be processed successfully
in the kernel based fast path. If they can not be handled by the kernel,
they will get passed on to user space. So user space still has to have
an implementation for these despite the in kernel acceleration.</p>
<p>This capability is always enabled.</p>
</div>
<div class="section" id="kvm-create-spapr-tce-64">
<h2>4.98 KVM_CREATE_SPAPR_TCE_64<a class="headerlink" href="#kvm-create-spapr-tce-64" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SPAPR_TCE_64
Architectures: powerpc
Type: vm ioctl
Parameters: struct kvm_create_spapr_tce_64 (in)
Returns: file descriptor for manipulating the created TCE table</p>
<p>This is an extension for KVM_CAP_SPAPR_TCE which only supports 32bit
windows, described in 4.62 KVM_CREATE_SPAPR_TCE</p>
<p>This capability uses extended struct in ioctl interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_CAP_SPAPR_TCE_64 */</span>
<span class="k">struct</span> <span class="n">kvm_create_spapr_tce_64</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">liobn</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">page_shift</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span> <span class="cm">/* in pages */</span>
        <span class="n">__u64</span> <span class="n">size</span><span class="p">;</span>   <span class="cm">/* in pages */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The aim of extension is to support an additional bigger DMA window with
a variable page size.
KVM_CREATE_SPAPR_TCE_64 receives a 64bit window size, an IOMMU page shift and
a bus offset of the corresponding DMA window, &#64;size and &#64;offset are numbers
of IOMMU pages.</p>
<p>&#64;flags are not used at the moment.</p>
<p>The rest of functionality is identical to KVM_CREATE_SPAPR_TCE.</p>
</div>
<div class="section" id="kvm-reinject-control">
<h2>4.99 KVM_REINJECT_CONTROL<a class="headerlink" href="#kvm-reinject-control" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_REINJECT_CONTROL
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_reinject_control (in)
Returns: 0 on success,</p>
<blockquote>
<div><p>-EFAULT if struct kvm_reinject_control cannot be read,
-ENXIO if KVM_CREATE_PIT or KVM_CREATE_PIT2 didn’t succeed earlier.</p>
</div></blockquote>
<p>i8254 (PIT) has two modes, reinject and !reinject.  The default is reinject,
where KVM queues elapsed i8254 ticks and monitors completion of interrupt from
vector(s) that i8254 injects.  Reinject mode dequeues a tick and injects its
interrupt whenever there isn’t a pending interrupt from i8254.
!reinject mode injects an interrupt as soon as a tick arrives.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_reinject_control</span> <span class="p">{</span>
        <span class="n">__u8</span> <span class="n">pit_reinject</span><span class="p">;</span>
        <span class="n">__u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>pit_reinject = 0 (!reinject mode) is recommended, unless running an old
operating system that uses the PIT for timing (e.g. Linux 2.4.x).</p>
</div>
<div class="section" id="kvm-ppc-configure-v3-mmu">
<h2>4.100 KVM_PPC_CONFIGURE_V3_MMU<a class="headerlink" href="#kvm-ppc-configure-v3-mmu" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_RADIX_MMU or KVM_CAP_PPC_HASH_MMU_V3
Architectures: ppc
Type: vm ioctl
Parameters: struct kvm_ppc_mmuv3_cfg (in)
Returns: 0 on success,</p>
<blockquote>
<div><p>-EFAULT if struct kvm_ppc_mmuv3_cfg cannot be read,
-EINVAL if the configuration is invalid</p>
</div></blockquote>
<p>This ioctl controls whether the guest will use radix or HPT (hashed
page table) translation, and sets the pointer to the process table for
the guest.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_mmuv3_cfg</span> <span class="p">{</span>
        <span class="n">__u64</span>        <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u64</span>        <span class="n">process_table</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There are two bits that can be set in flags; KVM_PPC_MMUV3_RADIX and
KVM_PPC_MMUV3_GTSE.  KVM_PPC_MMUV3_RADIX, if set, configures the guest
to use radix tree translation, and if clear, to use HPT translation.
KVM_PPC_MMUV3_GTSE, if set and if KVM permits it, configures the guest
to be able to use the global TLB and SLB invalidation instructions;
if clear, the guest may not use these instructions.</p>
<p>The process_table field specifies the address and size of the guest
process table, which is in the guest’s space.  This field is formatted
as the second doubleword of the partition table entry, as defined in
the Power ISA V3.00, Book III section 5.7.6.1.</p>
</div>
<div class="section" id="kvm-ppc-get-rmmu-info">
<h2>4.101 KVM_PPC_GET_RMMU_INFO<a class="headerlink" href="#kvm-ppc-get-rmmu-info" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_RADIX_MMU
Architectures: ppc
Type: vm ioctl
Parameters: struct kvm_ppc_rmmu_info (out)
Returns: 0 on success,</p>
<blockquote>
<div><p>-EFAULT if struct kvm_ppc_rmmu_info cannot be written,
-EINVAL if no useful information can be returned</p>
</div></blockquote>
<p>This ioctl returns a structure containing two things: (a) a list
containing supported radix tree geometries, and (b) a list that maps
page sizes to put in the “AP” (actual page size) field for the tlbie
(TLB invalidate entry) instruction.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_rmmu_info</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kvm_ppc_radix_geom</span> <span class="p">{</span>
                <span class="n">__u8</span> <span class="n">page_shift</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">level_bits</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
                <span class="n">__u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="p">}</span>    <span class="n">geometries</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
        <span class="n">__u32</span>        <span class="n">ap_encodings</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The geometries[] field gives up to 8 supported geometries for the
radix page table, in terms of the log base 2 of the smallest page
size, and the number of bits indexed at each level of the tree, from
the PTE level up to the PGD level in that order.  Any unused entries
will have 0 in the page_shift field.</p>
<p>The ap_encodings gives the supported page sizes and their AP field
encodings, encoded with the AP value in the top 3 bits and the log
base 2 of the page size in the bottom 6 bits.</p>
</div>
<div class="section" id="kvm-ppc-resize-hpt-prepare">
<h2>4.102 KVM_PPC_RESIZE_HPT_PREPARE<a class="headerlink" href="#kvm-ppc-resize-hpt-prepare" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SPAPR_RESIZE_HPT
Architectures: powerpc
Type: vm ioctl
Parameters: struct kvm_ppc_resize_hpt (in)
Returns: 0 on successful completion,</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;0 if a new HPT is being prepared, the value is an estimated</dt><dd><p>number of milliseconds until preparation is complete</p>
</dd>
</dl>
<p>-EFAULT if struct kvm_reinject_control cannot be read,
-EINVAL if the supplied shift or flags are invalid
-ENOMEM if unable to allocate the new HPT
-ENOSPC if there was a hash collision when moving existing</p>
<blockquote>
<div><p>HPT entries to the new HPT</p>
</div></blockquote>
<p>-EIO on other error conditions</p>
</div></blockquote>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s
Hashed Page Table (HPT).  Specifically this starts, stops or monitors
the preparation of a new potential HPT for the guest, essentially
implementing the H_RESIZE_HPT_PREPARE hypercall.</p>
<p>If called with shift &gt; 0 when there is no pending HPT for the guest,
this begins preparation of a new pending HPT of size 2^(shift) bytes.
It then returns a positive integer with the estimated number of
milliseconds until preparation is complete.</p>
<p>If called when there is a pending HPT whose size does not match that
requested in the parameters, discards the existing pending HPT and
creates a new one as above.</p>
<dl class="simple">
<dt>If called when there is a pending HPT of the size requested, will:</dt><dd><ul class="simple">
<li><p>If preparation of the pending HPT is already complete, return 0</p></li>
<li><p>If preparation of the pending HPT has failed, return an error
code, then discard the pending HPT.</p></li>
<li><p>If preparation of the pending HPT is still in progress, return an
estimated number of milliseconds until preparation is complete.</p></li>
</ul>
</dd>
</dl>
<p>If called with shift == 0, discards any currently pending HPT and
returns 0 (i.e. cancels any in-progress preparation).</p>
<p>flags is reserved for future expansion, currently setting any bits in
flags will result in an -EINVAL.</p>
<p>Normally this will be called repeatedly with the same parameters until
it returns &lt;= 0.  The first call will initiate preparation, subsequent
ones will monitor preparation until it completes or fails.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_resize_hpt</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">shift</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-ppc-resize-hpt-commit">
<h2>4.103 KVM_PPC_RESIZE_HPT_COMMIT<a class="headerlink" href="#kvm-ppc-resize-hpt-commit" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_SPAPR_RESIZE_HPT
Architectures: powerpc
Type: vm ioctl
Parameters: struct kvm_ppc_resize_hpt (in)
Returns: 0 on successful completion,</p>
<blockquote>
<div><p>-EFAULT if struct kvm_reinject_control cannot be read,
-EINVAL if the supplied shift or flags are invalid
-ENXIO is there is no pending HPT, or the pending HPT doesn’t</p>
<blockquote>
<div><p>have the requested size</p>
</div></blockquote>
<p>-EBUSY if the pending HPT is not fully prepared
-ENOSPC if there was a hash collision when moving existing</p>
<blockquote>
<div><p>HPT entries to the new HPT</p>
</div></blockquote>
<p>-EIO on other error conditions</p>
</div></blockquote>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s
Hashed Page Table (HPT).  Specifically this requests that the guest be
transferred to working with the new HPT, essentially implementing the
H_RESIZE_HPT_COMMIT hypercall.</p>
<p>This should only be called after KVM_PPC_RESIZE_HPT_PREPARE has
returned 0 with the same parameters.  In other cases
KVM_PPC_RESIZE_HPT_COMMIT will return an error (usually -ENXIO or
-EBUSY, though others may be possible if the preparation was started,
but failed).</p>
<p>This will have undefined effects on the guest if it has not already
placed itself in a quiescent state where no vcpu will make MMU enabled
memory accesses.</p>
<p>On succsful completion, the pending HPT will become the guest’s active
HPT and the previous HPT will be discarded.</p>
<p>On failure, the guest will still be operating on its previous HPT.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_resize_hpt</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">shift</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="kvm-x86-get-mce-cap-supported">
<h2>4.104 KVM_X86_GET_MCE_CAP_SUPPORTED<a class="headerlink" href="#kvm-x86-get-mce-cap-supported" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_MCE
Architectures: x86
Type: system ioctl
Parameters: u64 mce_cap (out)
Returns: 0 on success, -1 on error</p>
<p>Returns supported MCE capabilities. The u64 mce_cap parameter
has the same format as the MSR_IA32_MCG_CAP register. Supported
capabilities will have the corresponding bits set.</p>
</div>
<div class="section" id="kvm-x86-setup-mce">
<h2>4.105 KVM_X86_SETUP_MCE<a class="headerlink" href="#kvm-x86-setup-mce" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_MCE
Architectures: x86
Type: vcpu ioctl
Parameters: u64 mcg_cap (in)
Returns: 0 on success,</p>
<blockquote>
<div><p>-EFAULT if u64 mcg_cap cannot be read,
-EINVAL if the requested number of banks is invalid,
-EINVAL if requested MCE capability is not supported.</p>
</div></blockquote>
<p>Initializes MCE support for use. The u64 mcg_cap parameter
has the same format as the MSR_IA32_MCG_CAP register and
specifies which capabilities should be enabled. The maximum
supported number of error-reporting banks can be retrieved when
checking for KVM_CAP_MCE. The supported capabilities can be
retrieved with KVM_X86_GET_MCE_CAP_SUPPORTED.</p>
</div>
<div class="section" id="kvm-x86-set-mce">
<h2>4.106 KVM_X86_SET_MCE<a class="headerlink" href="#kvm-x86-set-mce" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_MCE
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_x86_mce (in)
Returns: 0 on success,</p>
<blockquote>
<div><p>-EFAULT if struct kvm_x86_mce cannot be read,
-EINVAL if the bank number is invalid,
-EINVAL if VAL bit is not set in status field.</p>
</div></blockquote>
<p>Inject a machine check error (MCE) into the guest. The input
parameter is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_x86_mce</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">status</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">addr</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">misc</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">mcg_status</span><span class="p">;</span>
        <span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
        <span class="n">__u8</span> <span class="n">pad1</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
        <span class="n">__u64</span> <span class="n">pad2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the MCE being reported is an uncorrected error, KVM will
inject it as an MCE exception into the guest. If the guest
MCG_STATUS register reports that an MCE is in progress, KVM
causes an KVM_EXIT_SHUTDOWN vmexit.</p>
<p>Otherwise, if the MCE is a corrected error, KVM will just
store it in the corresponding bank (provided this bank is
not holding a previously reported uncorrected error).</p>
</div>
<div class="section" id="kvm-s390-get-cmma-bits">
<h2>4.107 KVM_S390_GET_CMMA_BITS<a class="headerlink" href="#kvm-s390-get-cmma-bits" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_CMMA_MIGRATION
Architectures: s390
Type: vm ioctl
Parameters: struct kvm_s390_cmma_log (in, out)
Returns: 0 on success, a negative value on error</p>
<p>This ioctl is used to get the values of the CMMA bits on the s390
architecture. It is meant to be used in two scenarios:
- During live migration to save the CMMA values. Live migration needs</p>
<blockquote>
<div><p>to be enabled via the KVM_REQ_START_MIGRATION VM property.</p>
</div></blockquote>
<ul class="simple">
<li><p>To non-destructively peek at the CMMA values, with the flag
KVM_S390_CMMA_PEEK set.</p></li>
</ul>
<p>The ioctl takes parameters via the kvm_s390_cmma_log struct. The desired
values are written to a buffer whose location is indicated via the “values”
member in the kvm_s390_cmma_log struct.  The values in the input struct are
also updated as needed.
Each CMMA value takes up one byte.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_cmma_log</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">start_gfn</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">count</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="n">__u64</span> <span class="n">remaining</span><span class="p">;</span>
                <span class="n">__u64</span> <span class="n">mask</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">__u64</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>start_gfn is the number of the first guest frame whose CMMA values are
to be retrieved,</p>
<p>count is the length of the buffer in bytes,</p>
<p>values points to the buffer where the result will be written to.</p>
<p>If count is greater than KVM_S390_SKEYS_MAX, then it is considered to be
KVM_S390_SKEYS_MAX. KVM_S390_SKEYS_MAX is re-used for consistency with
other ioctls.</p>
<p>The result is written in the buffer pointed to by the field values, and
the values of the input parameter are updated as follows.</p>
<p>Depending on the flags, different actions are performed. The only
supported flag so far is KVM_S390_CMMA_PEEK.</p>
<p>The default behaviour if KVM_S390_CMMA_PEEK is not set is:
start_gfn will indicate the first page frame whose CMMA bits were dirty.
It is not necessarily the same as the one passed as input, as clean pages
are skipped.</p>
<p>count will indicate the number of bytes actually written in the buffer.
It can (and very often will) be smaller than the input value, since the
buffer is only filled until 16 bytes of clean values are found (which
are then not copied in the buffer). Since a CMMA migration block needs
the base address and the length, for a total of 16 bytes, we will send
back some clean data if there is some dirty data afterwards, as long as
the size of the clean data does not exceed the size of the header. This
allows to minimize the amount of data to be saved or transferred over
the network at the expense of more roundtrips to userspace. The next
invocation of the ioctl will skip over all the clean values, saving
potentially more than just the 16 bytes we found.</p>
<p>If KVM_S390_CMMA_PEEK is set:
the existing storage attributes are read even when not in migration
mode, and no other action is performed;</p>
<p>the output start_gfn will be equal to the input start_gfn,</p>
<p>the output count will be equal to the input count, except if the end of
memory has been reached.</p>
<p>In both cases:
the field “remaining” will indicate the total number of dirty CMMA values
still remaining, or 0 if KVM_S390_CMMA_PEEK is set and migration mode is
not enabled.</p>
<p>mask is unused.</p>
<p>values points to the userspace buffer where the result will be stored.</p>
<p>This ioctl can fail with -ENOMEM if not enough memory can be allocated to
complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if
KVM_S390_CMMA_PEEK is not set but migration mode was not enabled, with
-EFAULT if the userspace address is invalid or if no page table is
present for the addresses (e.g. when using hugepages).</p>
</div>
<div class="section" id="kvm-s390-set-cmma-bits">
<h2>4.108 KVM_S390_SET_CMMA_BITS<a class="headerlink" href="#kvm-s390-set-cmma-bits" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_S390_CMMA_MIGRATION
Architectures: s390
Type: vm ioctl
Parameters: struct kvm_s390_cmma_log (in)
Returns: 0 on success, a negative value on error</p>
<p>This ioctl is used to set the values of the CMMA bits on the s390
architecture. It is meant to be used during live migration to restore
the CMMA values, but there are no restrictions on its use.
The ioctl takes parameters via the kvm_s390_cmma_values struct.
Each CMMA value takes up one byte.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_s390_cmma_log</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">start_gfn</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">count</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="n">__u64</span> <span class="n">remaining</span><span class="p">;</span>
                <span class="n">__u64</span> <span class="n">mask</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">__u64</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>start_gfn indicates the starting guest frame number,</p>
<p>count indicates how many values are to be considered in the buffer,</p>
<p>flags is not used and must be 0.</p>
<p>mask indicates which PGSTE bits are to be considered.</p>
<p>remaining is not used.</p>
<p>values points to the buffer in userspace where to store the values.</p>
<p>This ioctl can fail with -ENOMEM if not enough memory can be allocated to
complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if
the count field is too large (e.g. more than KVM_S390_CMMA_SIZE_MAX) or
if the flags field was not 0, with -EFAULT if the userspace address is
invalid, if invalid pages are written to (e.g. after the end of memory)
or if no page table is present for the addresses (e.g. when using
hugepages).</p>
</div>
<div class="section" id="kvm-ppc-get-cpu-char">
<h2>4.109 KVM_PPC_GET_CPU_CHAR<a class="headerlink" href="#kvm-ppc-get-cpu-char" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_PPC_GET_CPU_CHAR
Architectures: powerpc
Type: vm ioctl
Parameters: struct kvm_ppc_cpu_char (out)
Returns: 0 on successful completion</p>
<blockquote>
<div><p>-EFAULT if struct kvm_ppc_cpu_char cannot be written</p>
</div></blockquote>
<p>This ioctl gives userspace information about certain characteristics
of the CPU relating to speculative execution of instructions and
possible information leakage resulting from speculative execution (see
CVE-2017-5715, CVE-2017-5753 and CVE-2017-5754).  The information is
returned in struct kvm_ppc_cpu_char, which looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_ppc_cpu_char</span> <span class="p">{</span>
        <span class="n">__u64</span>        <span class="n">character</span><span class="p">;</span>              <span class="cm">/* characteristics of the CPU */</span>
        <span class="n">__u64</span>        <span class="n">behaviour</span><span class="p">;</span>              <span class="cm">/* recommended software behaviour */</span>
        <span class="n">__u64</span>        <span class="n">character_mask</span><span class="p">;</span>         <span class="cm">/* valid bits in character */</span>
        <span class="n">__u64</span>        <span class="n">behaviour_mask</span><span class="p">;</span>         <span class="cm">/* valid bits in behaviour */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For extensibility, the character_mask and behaviour_mask fields
indicate which bits of character and behaviour have been filled in by
the kernel.  If the set of defined bits is extended in future then
userspace will be able to tell whether it is running on a kernel that
knows about the new bits.</p>
<p>The character field describes attributes of the CPU which can help
with preventing inadvertent information disclosure - specifically,
whether there is an instruction to flash-invalidate the L1 data cache
(ori 30,30,0 or mtspr SPRN_TRIG2,rN), whether the L1 data cache is set
to a mode where entries can only be used by the thread that created
them, whether the bcctr[l] instruction prevents speculation, and
whether a speculation barrier instruction (ori 31,31,0) is provided.</p>
<p>The behaviour field describes actions that software should take to
prevent inadvertent information disclosure, and thus describes which
vulnerabilities the hardware is subject to; specifically whether the
L1 data cache should be flushed when returning to user mode from the
kernel, and whether a speculation barrier should be placed between an
array bounds check and the array access.</p>
<p>These fields use the same bit definitions as the new
H_GET_CPU_CHARACTERISTICS hypercall.</p>
</div>
<div class="section" id="kvm-memory-encrypt-op">
<h2>4.110 KVM_MEMORY_ENCRYPT_OP<a class="headerlink" href="#kvm-memory-encrypt-op" title="Permalink to this headline">¶</a></h2>
<p>Capability: basic
Architectures: x86
Type: system
Parameters: an opaque platform specific structure (in/out)
Returns: 0 on success; -1 on error</p>
<p>If the platform supports creating encrypted VMs then this ioctl can be used
for issuing platform-specific memory encryption commands to manage those
encrypted VMs.</p>
<p>Currently, this ioctl is used for issuing Secure Encrypted Virtualization
(SEV) commands on AMD Processors. The SEV commands are defined in
Documentation/virtual/kvm/amd-memory-encryption.rst.</p>
</div>
<div class="section" id="kvm-memory-encrypt-reg-region">
<h2>4.111 KVM_MEMORY_ENCRYPT_REG_REGION<a class="headerlink" href="#kvm-memory-encrypt-reg-region" title="Permalink to this headline">¶</a></h2>
<p>Capability: basic
Architectures: x86
Type: system
Parameters: struct kvm_enc_region (in)
Returns: 0 on success; -1 on error</p>
<p>This ioctl can be used to register a guest memory region which may
contain encrypted data (e.g. guest RAM, SMRAM etc).</p>
<p>It is used in the SEV-enabled guest. When encryption is enabled, a guest
memory region may contain encrypted data. The SEV memory encryption
engine uses a tweak such that two identical plaintext pages, each at
different locations will have differing ciphertexts. So swapping or
moving ciphertext of those pages will not result in plaintext being
swapped. So relocating (or migrating) physical backing pages for the SEV
guest will require some additional steps.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current SEV key management spec does not provide commands to
swap or migrate (move) ciphertext pages. Hence, for now we pin the guest
memory region registered with the ioctl.</p>
</div>
</div>
<div class="section" id="kvm-memory-encrypt-unreg-region">
<h2>4.112 KVM_MEMORY_ENCRYPT_UNREG_REGION<a class="headerlink" href="#kvm-memory-encrypt-unreg-region" title="Permalink to this headline">¶</a></h2>
<p>Capability: basic
Architectures: x86
Type: system
Parameters: struct kvm_enc_region (in)
Returns: 0 on success; -1 on error</p>
<p>This ioctl can be used to unregister the guest memory region registered
with KVM_MEMORY_ENCRYPT_REG_REGION ioctl above.</p>
</div>
<div class="section" id="kvm-hyperv-eventfd">
<h2>4.113 KVM_HYPERV_EVENTFD<a class="headerlink" href="#kvm-hyperv-eventfd" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_HYPERV_EVENTFD
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_hyperv_eventfd (in)</p>
<p>This ioctl (un)registers an eventfd to receive notifications from the guest on
the specified Hyper-V connection id through the SIGNAL_EVENT hypercall, without
causing a user exit.  SIGNAL_EVENT hypercall with non-zero event flag number
(bits 24-31) still triggers a KVM_EXIT_HYPERV_HCALL user exit.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_hyperv_eventfd</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">conn_id</span><span class="p">;</span>
        <span class="n">__s32</span> <span class="n">fd</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The conn_id field should fit within 24 bits:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define KVM_HYPERV_CONN_ID_MASK              0x00ffffff</span>
</pre></div>
</div>
<p>The acceptable values for the flags field are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define KVM_HYPERV_EVENTFD_DEASSIGN  (1 &lt;&lt; 0)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Returns: 0 on success,</dt><dd><p>-EINVAL if conn_id or flags is outside the allowed range
-ENOENT on deassign if the conn_id isn’t registered
-EEXIST on assign if the conn_id is already registered</p>
</dd>
</dl>
</div>
<div class="section" id="kvm-get-nested-state">
<h2>4.114 KVM_GET_NESTED_STATE<a class="headerlink" href="#kvm-get-nested-state" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_NESTED_STATE
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_nested_state (in/out)
Returns: 0 on success, -1 on error
Errors:</p>
<blockquote>
<div><dl class="simple">
<dt>E2BIG:     the total state size (including the fixed-size part of struct</dt><dd><p>kvm_nested_state) exceeds the value of ‘size’ specified by
the user; the size required will be written into size.</p>
</dd>
</dl>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_nested_state</span> <span class="p">{</span>
        <span class="n">__u16</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u16</span> <span class="n">format</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">size</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">kvm_vmx_nested_state</span> <span class="n">vmx</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">kvm_svm_nested_state</span> <span class="n">svm</span><span class="p">;</span>
                <span class="n">__u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">120</span><span class="p">];</span>
        <span class="p">};</span>
        <span class="n">__u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define KVM_STATE_NESTED_GUEST_MODE  0x00000001</span>
<span class="cp">#define KVM_STATE_NESTED_RUN_PENDING 0x00000002</span>

<span class="cp">#define KVM_STATE_NESTED_SMM_GUEST_MODE      0x00000001</span>
<span class="cp">#define KVM_STATE_NESTED_SMM_VMXON   0x00000002</span>

<span class="k">struct</span> <span class="n">kvm_vmx_nested_state</span> <span class="p">{</span>
        <span class="n">__u64</span> <span class="n">vmxon_pa</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">vmcs_pa</span><span class="p">;</span>

        <span class="k">struct</span> <span class="p">{</span>
                <span class="n">__u16</span> <span class="n">flags</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">smm</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl copies the vcpu’s nested virtualization state from the kernel to
userspace.</p>
<p>The maximum size of the state, including the fixed-size part of struct
kvm_nested_state, can be retrieved by passing KVM_CAP_NESTED_STATE to
the KVM_CHECK_EXTENSION ioctl().</p>
</div>
<div class="section" id="kvm-set-nested-state">
<h2>4.115 KVM_SET_NESTED_STATE<a class="headerlink" href="#kvm-set-nested-state" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_NESTED_STATE
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_nested_state (in)
Returns: 0 on success, -1 on error</p>
<p>This copies the vcpu’s kvm_nested_state struct from userspace to the kernel.  For
the definition of struct kvm_nested_state, see KVM_GET_NESTED_STATE.</p>
</div>
<div class="section" id="kvm-un-register-coalesced-mmio">
<h2>4.116 KVM_(UN)REGISTER_COALESCED_MMIO<a class="headerlink" href="#kvm-un-register-coalesced-mmio" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Capability: KVM_CAP_COALESCED_MMIO (for coalesced mmio)</dt><dd><p>KVM_CAP_COALESCED_PIO (for coalesced pio)</p>
</dd>
</dl>
<p>Architectures: all
Type: vm ioctl
Parameters: struct kvm_coalesced_mmio_zone
Returns: 0 on success, &lt; 0 on error</p>
<p>Coalesced I/O is a performance optimization that defers hardware
register write emulation so that userspace exits are avoided.  It is
typically used to reduce the overhead of emulating frequently accessed
hardware registers.</p>
<p>When a hardware register is configured for coalesced I/O, write accesses
do not exit to userspace and their value is recorded in a ring buffer
that is shared between kernel and userspace.</p>
<p>Coalesced I/O is used if one or more write accesses to a hardware
register can be deferred until a read or a write to another hardware
register on the same device.  This last access will cause a vmexit and
userspace will process accesses from the ring buffer before emulating
it. That will avoid exiting to userspace on repeated writes.</p>
<p>Coalesced pio is based on coalesced mmio. There is little difference
between coalesced mmio and pio except that coalesced pio records accesses
to I/O ports.</p>
</div>
<div class="section" id="kvm-clear-dirty-log-vm-ioctl">
<h2>4.117 KVM_CLEAR_DIRTY_LOG (vm ioctl)<a class="headerlink" href="#kvm-clear-dirty-log-vm-ioctl" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_MANUAL_DIRTY_LOG_PROTECT
Architectures: x86
Type: vm ioctl
Parameters: struct kvm_dirty_log (in)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* for KVM_CLEAR_DIRTY_LOG */</span>
<span class="k">struct</span> <span class="n">kvm_clear_dirty_log</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">slot</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">num_pages</span><span class="p">;</span>
        <span class="n">__u64</span> <span class="n">first_page</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span> <span class="cm">/* one bit per page */</span>
                <span class="n">__u64</span> <span class="n">padding</span><span class="p">;</span>
        <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The ioctl clears the dirty status of pages in a memory slot, according to
the bitmap that is passed in struct kvm_clear_dirty_log’s dirty_bitmap
field.  Bit 0 of the bitmap corresponds to page “first_page” in the
memory slot, and num_pages is the size in bits of the input bitmap.
Both first_page and num_pages must be a multiple of 64.  For each bit
that is set in the input bitmap, the corresponding page is marked “clean”
in KVM’s dirty bitmap, and dirty tracking is re-enabled for that page
(for example via write-protection, or by clearing the dirty bit in
a page table entry).</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 specifies
the address space for which you want to return the dirty bitmap.
They must be less than the value that KVM_CHECK_EXTENSION returns for
the KVM_CAP_MULTI_ADDRESS_SPACE capability.</p>
<p>This ioctl is mostly useful when KVM_CAP_MANUAL_DIRTY_LOG_PROTECT
is enabled; for more information, see the description of the capability.
However, it can always be used as long as KVM_CHECK_EXTENSION confirms
that KVM_CAP_MANUAL_DIRTY_LOG_PROTECT is present.</p>
</div>
<div class="section" id="kvm-get-supported-hv-cpuid">
<h2>4.118 KVM_GET_SUPPORTED_HV_CPUID<a class="headerlink" href="#kvm-get-supported-hv-cpuid" title="Permalink to this headline">¶</a></h2>
<p>Capability: KVM_CAP_HYPERV_CPUID
Architectures: x86
Type: vcpu ioctl
Parameters: struct kvm_cpuid2 (in/out)
Returns: 0 on success, -1 on error</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">nent</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">function</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">index</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">eax</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ebx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">ecx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">edx</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This ioctl returns x86 cpuid features leaves related to Hyper-V emulation in
KVM.  Userspace can use the information returned by this ioctl to construct
cpuid information presented to guests consuming Hyper-V enlightenments (e.g.
Windows or Hyper-V guests).</p>
<p>CPUID feature leaves returned by this ioctl are defined by Hyper-V Top Level
Functional Specification (TLFS). These leaves can’t be obtained with
KVM_GET_SUPPORTED_CPUID ioctl because some of them intersect with KVM feature
leaves (0x40000000, 0x40000001).</p>
<dl class="simple">
<dt>Currently, the following list of CPUID leaves are returned:</dt><dd><p>HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS
HYPERV_CPUID_INTERFACE
HYPERV_CPUID_VERSION
HYPERV_CPUID_FEATURES
HYPERV_CPUID_ENLIGHTMENT_INFO
HYPERV_CPUID_IMPLEMENT_LIMITS
HYPERV_CPUID_NESTED_FEATURES</p>
</dd>
</dl>
<p>HYPERV_CPUID_NESTED_FEATURES leaf is only exposed when Enlightened VMCS was
enabled on the corresponding vCPU (KVM_CAP_HYPERV_ENLIGHTENED_VMCS).</p>
<p>Userspace invokes KVM_GET_SUPPORTED_CPUID by passing a kvm_cpuid2 structure
with the ‘nent’ field indicating the number of entries in the variable-size
array ‘entries’.  If the number of entries is too low to describe all Hyper-V
feature leaves, an error (E2BIG) is returned. If the number is more or equal
to the number of Hyper-V feature leaves, the ‘nent’ field is adjusted to the
number of valid entries in the ‘entries’ array, which is then filled.</p>
<p>‘index’ and ‘flags’ fields in ‘struct kvm_cpuid_entry2’ are currently reserved,
userspace should not expect to get any particular value there.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="5.html" class="btn btn-neutral float-right" title="5. The kvm_run structure" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="3.html" class="btn btn-neutral float-left" title="3. Extensions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Takumi Takahashi

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-62539992-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>